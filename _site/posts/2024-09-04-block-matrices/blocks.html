<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dan Simpson">
<meta name="dcterms.date" content="2024-09-04">
<meta name="description" content="I was writing a longer thing, but it was too long, so hey. Let’s just do this for a change">

<title>Un garçon pas comme les autres (Bayes) - Random C++ Part 1: Building a block sparse matrix in Eigen</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Un garçon pas comme les autres (Bayes) - Random C++ Part 1: Building a block sparse matrix in Eigen">
<meta property="og:description" content="I was writing a longer thing, but it was too long, so hey. Let’s just do this for a change">
<meta property="og:image" content="https://dansblog.netlify.app/posts/2024-09-04-block-matrices/ravens.JPEG">
<meta property="og:site_name" content="Un garçon pas comme les autres (Bayes)">
<meta name="twitter:title" content="Building a block sparse matrix in Eigen">
<meta name="twitter:description" content="I was writing a longer thing, but it was too long, so hey. Let’s just do this for a change">
<meta name="twitter:image" content="https://dansblog.netlify.app/posts/2024-09-04-block-matrices/ravens.JPEG">
<meta name="twitter:creator" content="@dan_p_simpson">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Un garçon pas comme les autres (Bayes)</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About this blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/dan_p_simpson"> <i class="bi bi-twitter" role="img" aria-label="twitter">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/dpsimpson"> <i class="bi bi-github" role="img" aria-label="github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://dansblog.netlify.app"> <i class="bi bi-person-circle" role="img" aria-label="website">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Random C++ Part 1: Building a block sparse matrix in Eigen</h1>
                  <div>
        <div class="description">
          I was writing a longer thing, but it was too long, so hey. Let’s just do this for a change
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Stan</div>
                <div class="quarto-category">Sparse matrices</div>
                <div class="quarto-category">Autodiff</div>
                <div class="quarto-category">Eigen</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p><a href="https://dansblog.netlify.app">Dan Simpson</a> </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 4, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#c-plumbing-building-a-2x2-block-sparse-matrix-from-a-sparse-11-block-and-two-dense-matrices" id="toc-c-plumbing-building-a-2x2-block-sparse-matrix-from-a-sparse-11-block-and-two-dense-matrices" class="nav-link active" data-scroll-target="#c-plumbing-building-a-2x2-block-sparse-matrix-from-a-sparse-11-block-and-two-dense-matrices">C++ Plumbing: Building a 2x2 block sparse matrix from a sparse (1,1) block and two dense matrices</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>I’ll be honest with y’all. I was writing something else. It was really long and was getting annoying to edit and was probably never going to be finished. So instead of doing that, I am just going to post this. It’s about making a block matrix in a Stan-compatible way. Why?? Because I wanted to be able to do this.</p>
<p>There is no context forthcoming. There are no good jokes. Just building one sparse matrix.</p>
<p>Enjoy</p>
<section id="c-plumbing-building-a-2x2-block-sparse-matrix-from-a-sparse-11-block-and-two-dense-matrices" class="level2">
<h2 class="anchored" data-anchor-id="c-plumbing-building-a-2x2-block-sparse-matrix-from-a-sparse-11-block-and-two-dense-matrices">C++ Plumbing: Building a 2x2 block sparse matrix from a sparse (1,1) block and two dense matrices</h2>
<p>The first thing that we need to do is build a block-sparse matrix. We know that this matrix is symmetric so we only need to store the lower-triangle.</p>
<p>In general, this is not the most difficult task in the world. We have <a href="https://dansblog.netlify.app/posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices#so-how-do-we-store-a-sparse-matrix">already talked about how we store sparse matrices</a> and, in particular, have had some fun with the Compressed Column Storage (CCS) scheme, which stores sparse matrices column-by-column. In the lingo, we call this <em>column major</em> storage.</p>
<p>When any array of numbers is stored in memory by a program, it is stored as a long vector and when you index into it (using something like <code>A[i,j]</code>) this is just some syntactic sugar for finding the correct value in that long vector.</p>
<p>Some languages, such as Fortran and Matlab, and libraries, such as <a href="https://gitlab.com/libeigen/eigen">Eigen</a>, store arrays in column major order. Others, like C/C++ and Python, use row-major storage. Stan is written in C++ but all of its linear algebra is done using Eigen, so we are going to use column-major storage.</p>
<p>It may seem catastrophically nerdy to be talking about internal storage orders for arrays in different languages, but I promise you this is <em>incredibly</em> important. If you want to write any sort of performant code, it’s extremely important that your algorithms are aligned with the internal storage order. That means that we need to prefer algorithms that run down columns of matrices over ones that run across rows.</p>
<p>This is because computers are clever and when you ask them for, eg <code>A[0,0]</code>, the CPU will actually load the first few entries of the 0th <em>column</em><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> of <code>A</code> in anticipation<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> that you will need <code>A[0,1]</code> and its friends next. If you instead next ask for <code>A[1,0]</code>, the CPU has to throw its pre-loaded stuff out, reach out to some potentially distant memory and try again. When an array has a lot of rows, these cache misses<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> noticeably degrade the performance of a program.</p>
<p>All of that is to say that this is actually not too too hard to implement because we are just interleaving some contiguous chunks of a vector. While the main loop is pretty straightforward, C++ is truly a journey. So it’s gonna be like 100 lines of code.</p>
<p>The structure is</p>
<ol type="1">
<li><p>Allocate 3 arrays to store the outer index (which column?), the inner index (which row?), and the value.</p></li>
<li><p>Iterate through each column of the matrix, only storing the lower triangle.</p></li>
<li><p>Return an <code>Eigen::SparseMatrix&lt;double&gt;</code> built from those arrays.</p></li>
</ol>
<p>There are essentially two challenges in doing this. Firstly, the number of columns and then number of non-zeros are not known at compile time so we need to allocate dynamic memory on the heap. This is always a risky proposition in C++ as it’s pretty easy to screw up and end up with a memory leak. To get around this, I’m using the RAII (resource acquisition is instantiation) pattern, which basically encapsulates all the memory usage inside a functor, who’s call method return a sparse symmetric matrix.</p>
<p>The second challenge is that the Eigen API demands raw pointers. So this is going to have that good old fashioned <code>*ptr++</code> action.</p>
<p>Without further ado, here is the code. I’ll explain some key bits after.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/meta/is_eigen_sparse_base.hpp&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/meta/is_eigen.hpp&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/meta/is_stan_scalar.hpp&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/meta/base_type.hpp&gt;</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/err/check_size_match.hpp&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/fun/to_ref.hpp&gt;</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="pp">#include </span><span class="im">&lt;Eigen/SparseCore&gt;</span></span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="kw">namespace</span> stan <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">namespace</span> math <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11"></a></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="kw">typedef</span> Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;::</span>StorageIndex StorageIndex<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="co">// The require_ statements are defined in the first #include</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> SpMat<span class="op">,</span> <span class="kw">typename</span> EigMat1<span class="op">,</span> <span class="kw">typename</span> EigMat2<span class="op">,</span> </span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="dt">require_eigen_sparse_base_t</span><span class="op">&lt;</span>SpMat<span class="op">&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">,</span></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="dt">require_all_eigen_t</span><span class="op">&lt;</span>EigMat1<span class="op">,</span> EigMat2<span class="op">&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">,</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="dt">require_all_stan_scalar_t</span><span class="op">&lt;</span><span class="dt">base_type_t</span><span class="op">&lt;</span>SpMat<span class="op">&gt;,</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>                          <span class="dt">base_type_t</span><span class="op">&lt;</span>EigMat1<span class="op">&gt;,</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>                          <span class="dt">base_type_t</span><span class="op">&lt;</span>EigMat2<span class="op">&gt;&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">&gt;</span>  </span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="kw">class</span> Block_sparse_lower <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>    <span class="co">/* </span></span>
<span id="cb1-23"><a href="#cb1-23"></a><span class="co">    A RAII functor class because Jesus hates memory leaks</span></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="co">    Make this encapsulate the whole thing.</span></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="co">    You may be asking why I'm using arrays and pointers</span></span>
<span id="cb1-26"><a href="#cb1-26"></a><span class="co">    like I'm writing in C, and the answer is </span></span>
<span id="cb1-27"><a href="#cb1-27"></a><span class="co">    "that's the interface to Map". The dream of the </span></span>
<span id="cb1-28"><a href="#cb1-28"></a><span class="co">    C-90 is alive and well in the eigen code base.</span></span>
<span id="cb1-29"><a href="#cb1-29"></a></span>
<span id="cb1-30"><a href="#cb1-30"></a><span class="co">    Anyway, `operator ()` returns a sparseMatrixMap</span></span>
<span id="cb1-31"><a href="#cb1-31"></a><span class="co">    */</span></span>
<span id="cb1-32"><a href="#cb1-32"></a>    <span class="kw">using</span> T <span class="op">=</span> <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">&lt;</span>SpMat<span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb1-33"><a href="#cb1-33"></a>   </span>
<span id="cb1-34"><a href="#cb1-34"></a>    StorageIndex<span class="op">*</span> <span class="va">m_outer</span><span class="op">;</span></span>
<span id="cb1-35"><a href="#cb1-35"></a>    StorageIndex<span class="op">*</span> <span class="va">m_inner</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36"></a>    T<span class="op">*</span> <span class="va">m_val</span><span class="op">;</span></span>
<span id="cb1-37"><a href="#cb1-37"></a>    StorageIndex <span class="va">m_cols</span><span class="op">;</span></span>
<span id="cb1-38"><a href="#cb1-38"></a>    StorageIndex <span class="va">m_nnz</span><span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39"></a></span>
<span id="cb1-40"><a href="#cb1-40"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb1-41"><a href="#cb1-41"></a></span>
<span id="cb1-42"><a href="#cb1-42"></a>    Block_sparse_lower<span class="op">(</span></span>
<span id="cb1-43"><a href="#cb1-43"></a>        <span class="at">const</span> SpMat<span class="op">&amp;</span> top_left<span class="op">,</span> </span>
<span id="cb1-44"><a href="#cb1-44"></a>        <span class="at">const</span> EigMat1<span class="op">&amp;</span> bottom_left<span class="op">,</span> </span>
<span id="cb1-45"><a href="#cb1-45"></a>        <span class="at">const</span> EigMat2<span class="op">&amp;</span> bottom_right</span>
<span id="cb1-46"><a href="#cb1-46"></a>        <span class="op">)</span> </span>
<span id="cb1-47"><a href="#cb1-47"></a>    <span class="op">{</span></span>
<span id="cb1-48"><a href="#cb1-48"></a>        <span class="co">// only eval once</span></span>
<span id="cb1-49"><a href="#cb1-49"></a>        <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> tl_ref <span class="op">=</span> to_ref<span class="op">(</span>top_left<span class="op">);</span></span>
<span id="cb1-50"><a href="#cb1-50"></a>        <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> bl_ref <span class="op">=</span> to_ref<span class="op">(</span>bottom_left<span class="op">);</span></span>
<span id="cb1-51"><a href="#cb1-51"></a>        <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> br_ref <span class="op">=</span> to_ref<span class="op">(</span>bottom_right<span class="op">);</span></span>
<span id="cb1-52"><a href="#cb1-52"></a></span>
<span id="cb1-53"><a href="#cb1-53"></a>        <span class="co">// Get sizes.</span></span>
<span id="cb1-54"><a href="#cb1-54"></a>        <span class="co">// NB tmp_nnz is an upper bound. Will only be correct if `top_left` is lower </span></span>
<span id="cb1-55"><a href="#cb1-55"></a>        <span class="co">// triangular. We will compute the real value on the fly.</span></span>
<span id="cb1-56"><a href="#cb1-56"></a>        <span class="at">const</span> StorageIndex ncols_tl <span class="op">=</span> tl_ref<span class="op">.</span>cols<span class="op">();</span></span>
<span id="cb1-57"><a href="#cb1-57"></a>        <span class="at">const</span> StorageIndex ncols_br <span class="op">=</span> br_ref<span class="op">.</span>cols<span class="op">();</span></span>
<span id="cb1-58"><a href="#cb1-58"></a>        <span class="at">const</span> StorageIndex tmp_nnz <span class="op">=</span> <span class="op">(</span>tl_ref<span class="op">.</span>nonZeros<span class="op">()</span> <span class="op">+</span> ncols_tl <span class="op">*</span> ncols_br </span>
<span id="cb1-59"><a href="#cb1-59"></a>                                        <span class="op">+</span> <span class="op">(</span>ncols_br <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> ncols_br <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb1-60"><a href="#cb1-60"></a></span>
<span id="cb1-61"><a href="#cb1-61"></a>        <span class="co">// check sizes</span></span>
<span id="cb1-62"><a href="#cb1-62"></a>        check_size_match<span class="op">(</span><span class="st">"Block_sparse_lower"</span><span class="op">,</span> <span class="st">"Columns of "</span><span class="op">,</span> <span class="st">"top_left "</span><span class="op">,</span> tl_ref<span class="op">.</span>cols<span class="op">(),</span> <span class="st">"Columns of "</span><span class="op">,</span> <span class="st">"Bottom Left"</span><span class="op">,</span> bl_ref<span class="op">.</span>cols<span class="op">());</span></span>
<span id="cb1-63"><a href="#cb1-63"></a>        check_size_match<span class="op">(</span><span class="st">"Block_sparse_lower"</span><span class="op">,</span> <span class="st">"Rows of "</span><span class="op">,</span> <span class="st">"bottom-left "</span><span class="op">,</span> bl_ref<span class="op">.</span>rows<span class="op">(),</span> <span class="st">"Rows of "</span><span class="op">,</span> <span class="st">"Bottom-right"</span><span class="op">,</span> br_ref<span class="op">.</span>rows<span class="op">());</span></span>
<span id="cb1-64"><a href="#cb1-64"></a>        </span>
<span id="cb1-65"><a href="#cb1-65"></a>        <span class="co">// Allocate!</span></span>
<span id="cb1-66"><a href="#cb1-66"></a>        <span class="va">m_cols</span> <span class="op">=</span> ncols_tl <span class="op">+</span> ncols_br<span class="op">;</span></span>
<span id="cb1-67"><a href="#cb1-67"></a></span>
<span id="cb1-68"><a href="#cb1-68"></a>        <span class="va">m_outer</span> <span class="op">=</span> <span class="kw">new</span> StorageIndex<span class="op">[</span><span class="va">m_cols</span> <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-69"><a href="#cb1-69"></a>        <span class="va">m_outer</span><span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">*</span>top_left<span class="op">.</span>outerIndexPtr<span class="op">();</span></span>
<span id="cb1-70"><a href="#cb1-70"></a>        <span class="va">m_inner</span> <span class="op">=</span> <span class="kw">new</span> StorageIndex<span class="op">[</span>tmp_nnz<span class="op">];</span></span>
<span id="cb1-71"><a href="#cb1-71"></a>        <span class="va">m_val</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span>tmp_nnz<span class="op">];</span></span>
<span id="cb1-72"><a href="#cb1-72"></a>        </span>
<span id="cb1-73"><a href="#cb1-73"></a>        T<span class="op">*</span> p_val <span class="op">=</span> <span class="va">m_val</span><span class="op">;</span></span>
<span id="cb1-74"><a href="#cb1-74"></a>        StorageIndex<span class="op">*</span> p_inner <span class="op">=</span> <span class="va">m_inner</span><span class="op">;</span></span>
<span id="cb1-75"><a href="#cb1-75"></a>        StorageIndex out_nnz <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-76"><a href="#cb1-76"></a>        </span>
<span id="cb1-77"><a href="#cb1-77"></a>        <span class="cf">for</span> <span class="op">(</span>StorageIndex j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> ncols_tl<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-78"><a href="#cb1-78"></a>            StorageIndex col_cnt <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-79"><a href="#cb1-79"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">typename</span> SpMat<span class="op">::</span>InnerIterator it<span class="op">(</span>tl_ref<span class="op">,</span> j<span class="op">);</span> it<span class="op">;</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-80"><a href="#cb1-80"></a>                <span class="cf">if</span> <span class="op">(</span>it<span class="op">.</span>row<span class="op">()</span> <span class="op">&lt;</span> j<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span> <span class="co">// lower triangle only</span></span>
<span id="cb1-81"><a href="#cb1-81"></a>                <span class="op">*</span>p_val<span class="op">++</span> <span class="op">=</span> it<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb1-82"><a href="#cb1-82"></a>                <span class="op">*</span>p_inner<span class="op">++</span> <span class="op">=</span> it<span class="op">.</span>row<span class="op">();</span></span>
<span id="cb1-83"><a href="#cb1-83"></a>                <span class="op">++</span>out_nnz<span class="op">;</span></span>
<span id="cb1-84"><a href="#cb1-84"></a>                <span class="op">++</span>col_cnt<span class="op">;</span></span>
<span id="cb1-85"><a href="#cb1-85"></a>            <span class="op">}</span></span>
<span id="cb1-86"><a href="#cb1-86"></a></span>
<span id="cb1-87"><a href="#cb1-87"></a>            <span class="cf">for</span> <span class="op">(</span>StorageIndex i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> ncols_br<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-88"><a href="#cb1-88"></a>                <span class="op">*</span>p_val<span class="op">++</span> <span class="op">=</span> bl_ref<span class="op">.</span>coeff<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb1-89"><a href="#cb1-89"></a>                <span class="op">*</span>p_inner<span class="op">++</span> <span class="op">=</span> ncols_tl <span class="op">+</span> i<span class="op">;</span></span>
<span id="cb1-90"><a href="#cb1-90"></a>                <span class="op">++</span>out_nnz<span class="op">;</span></span>
<span id="cb1-91"><a href="#cb1-91"></a>                <span class="op">++</span>col_cnt<span class="op">;</span></span>
<span id="cb1-92"><a href="#cb1-92"></a>            <span class="op">}</span></span>
<span id="cb1-93"><a href="#cb1-93"></a>        </span>
<span id="cb1-94"><a href="#cb1-94"></a>            <span class="va">m_outer</span><span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="va">m_outer</span><span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> col_cnt<span class="op">;</span></span>
<span id="cb1-95"><a href="#cb1-95"></a>        <span class="op">}</span></span>
<span id="cb1-96"><a href="#cb1-96"></a>        </span>
<span id="cb1-97"><a href="#cb1-97"></a>        <span class="cf">for</span> <span class="op">(</span>StorageIndex j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> ncols_br<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-98"><a href="#cb1-98"></a>            <span class="co">// only need lower triangle</span></span>
<span id="cb1-99"><a href="#cb1-99"></a>            <span class="cf">for</span> <span class="op">(</span>StorageIndex i <span class="op">=</span> j<span class="op">;</span> i <span class="op">&lt;</span> ncols_br<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-100"><a href="#cb1-100"></a>                <span class="op">*</span>p_val<span class="op">++</span> <span class="op">=</span> br_ref<span class="op">.</span>coeff<span class="op">(</span>i<span class="op">,</span>j<span class="op">);</span></span>
<span id="cb1-101"><a href="#cb1-101"></a>                <span class="op">*</span>p_inner<span class="op">++</span> <span class="op">=</span> ncols_tl <span class="op">+</span> i<span class="op">;</span></span>
<span id="cb1-102"><a href="#cb1-102"></a>                <span class="op">++</span>out_nnz<span class="op">;</span></span>
<span id="cb1-103"><a href="#cb1-103"></a>            <span class="op">}</span></span>
<span id="cb1-104"><a href="#cb1-104"></a>            <span class="va">m_outer</span><span class="op">[</span>ncols_tl<span class="op">+</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="va">m_outer</span><span class="op">[</span>ncols_tl <span class="op">+</span> j<span class="op">]</span> <span class="op">+</span> ncols_br <span class="op">-</span> j<span class="op">;</span></span>
<span id="cb1-105"><a href="#cb1-105"></a>        <span class="op">}</span></span>
<span id="cb1-106"><a href="#cb1-106"></a>        <span class="va">m_nnz</span> <span class="op">=</span> out_nnz<span class="op">;</span></span>
<span id="cb1-107"><a href="#cb1-107"></a>    <span class="op">}</span> <span class="co">// constructor</span></span>
<span id="cb1-108"><a href="#cb1-108"></a></span>
<span id="cb1-109"><a href="#cb1-109"></a>    <span class="op">~</span>Block_sparse_lower<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-110"><a href="#cb1-110"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_outer</span><span class="op">;</span></span>
<span id="cb1-111"><a href="#cb1-111"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_inner</span><span class="op">;</span></span>
<span id="cb1-112"><a href="#cb1-112"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_val</span><span class="op">;</span></span>
<span id="cb1-113"><a href="#cb1-113"></a>    <span class="op">}</span> <span class="co">// destructor</span></span>
<span id="cb1-114"><a href="#cb1-114"></a></span>
<span id="cb1-115"><a href="#cb1-115"></a>    Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">operator</span> <span class="op">()</span> <span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-116"><a href="#cb1-116"></a>        <span class="cf">return</span> <span class="kw">typename</span> Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span>T<span class="op">&gt;::</span>Map<span class="op">(</span></span>
<span id="cb1-117"><a href="#cb1-117"></a>            <span class="va">m_cols</span><span class="op">,</span> </span>
<span id="cb1-118"><a href="#cb1-118"></a>            <span class="va">m_cols</span><span class="op">,</span></span>
<span id="cb1-119"><a href="#cb1-119"></a>            <span class="va">m_nnz</span><span class="op">,</span></span>
<span id="cb1-120"><a href="#cb1-120"></a>            <span class="va">m_outer</span><span class="op">,</span></span>
<span id="cb1-121"><a href="#cb1-121"></a>            <span class="va">m_inner</span><span class="op">,</span></span>
<span id="cb1-122"><a href="#cb1-122"></a>            <span class="va">m_val</span></span>
<span id="cb1-123"><a href="#cb1-123"></a>        <span class="op">);</span>   </span>
<span id="cb1-124"><a href="#cb1-124"></a>    <span class="op">}</span> <span class="co">//operator ()</span></span>
<span id="cb1-125"><a href="#cb1-125"></a><span class="op">};</span> <span class="co">// Block_sparse_lower</span></span>
<span id="cb1-126"><a href="#cb1-126"></a><span class="op">}</span> <span class="co">// namespace math</span></span>
<span id="cb1-127"><a href="#cb1-127"></a><span class="op">}</span> <span class="co">// namespace stan</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The first thing you probably noticed was all the templates. Templates are a beautiful<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> feature of C++ and pretty much all that bit just allows us to have any matrix and sparse matrix from Eigen as long as they contain scalars (as opposed to autodiff variables). They also allow us to hack together a pre-C++20 version of <a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">concepts</a>, which is all of the <code>require_</code> statements.</p>
<p>Once we are actually in the class, it has three methods. The constructor takes in the three matrices, one sparse and two dense. It checks at compile time that they are all column-major and then starts doing its work. There’s nothing too exciting happening here. Some size checking, and then we run through the loop stacking the relevant vector parts onto each other.</p>
<p>The destructor frees the allocated memory (a core part of the RAII pattern).</p>
<p>Finally, we need to actually get access to this sparse matrix, which I implemented as a call operator. It returns a self-adjoint view (aka it will pretend to be symmetric when doing operations even though only the lower triangle is filled) of a <code>Map</code> of the three pointers. <code>Map</code>s are a nice way for Eigen to tell its internal <code>SparseMatrix</code> representation to look at the pieces of memory defined in this class when it is looking for inner indices, outer indices, or values. This doesn’t create a copy so it’s memory efficient.</p>
<p>So let’s test it. I’m going to run the following code .</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="pp">#include </span><span class="im">"sp_block.hpp"</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">"Eigen/SparseCore"</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="pp">#include </span><span class="im">"Eigen/Dense"</span></span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"-----------matrix test---------"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="dt">double</span> values<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="fl">1.</span><span class="op">,</span> <span class="fl">2.</span><span class="op">,</span> <span class="fl">3.</span><span class="op">,</span> <span class="fl">4.</span> <span class="op">};</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="dt">int</span> inner<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span> <span class="op">};</span> <span class="co">// nonzero row indices</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="dt">int</span> outer<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">4</span> <span class="op">};</span> <span class="co">// start index per column + 1 for last col</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>    Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> A <span class="op">=</span> Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;::</span>Map<span class="op">(</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>        <span class="dv">5</span> <span class="co">/*rows*/</span><span class="op">,</span> <span class="dv">5</span> <span class="co">/*cols*/</span><span class="op">,</span> <span class="dv">4</span> <span class="co">/*nonzeros*/</span><span class="op">,</span> outer<span class="op">,</span> inner<span class="op">,</span> values<span class="op">);</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>    </span>
<span id="cb2-15"><a href="#cb2-15"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> Eigen<span class="op">::</span>MatrixXd<span class="op">(</span>A<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16"></a></span>
<span id="cb2-17"><a href="#cb2-17"></a>    Eigen<span class="op">::</span>Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">&gt;</span> B<span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>    B <span class="op">&lt;&lt;</span> <span class="fl">1.</span><span class="op">,</span><span class="fl">2.</span><span class="op">,</span><span class="fl">3.</span><span class="op">,</span><span class="fl">4.</span><span class="op">,</span><span class="fl">5.</span><span class="op">,</span><span class="fl">1.</span><span class="op">,</span><span class="fl">2.</span><span class="op">,</span><span class="fl">3.</span><span class="op">,</span><span class="fl">4.</span><span class="op">,</span><span class="fl">5.</span><span class="op">;</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> B <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>    Eigen<span class="op">::</span>Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;</span> C<span class="op">;</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>    C <span class="op">&lt;&lt;</span> <span class="fl">1.</span><span class="op">,</span><span class="fl">1.</span><span class="op">,</span><span class="fl">1.</span><span class="op">,</span><span class="fl">1.</span><span class="op">;</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> C <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-23"><a href="#cb2-23"></a>    </span>
<span id="cb2-24"><a href="#cb2-24"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"   -------ans-------"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25"></a>    Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> D <span class="op">=</span> </span>
<span id="cb2-26"><a href="#cb2-26"></a>        stan<span class="op">::</span>math<span class="op">::</span>Block_sparse_lower<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>A<span class="op">),</span> <span class="kw">decltype</span><span class="op">(</span>B<span class="op">),</span><span class="kw">decltype</span><span class="op">(</span>C<span class="op">)&gt;(</span></span>
<span id="cb2-27"><a href="#cb2-27"></a>            A<span class="op">.</span>triangularView<span class="op">&lt;</span>Eigen<span class="op">::</span>Lower<span class="op">&gt;(),</span> B<span class="op">,</span> C<span class="op">.</span>triangularView<span class="op">&lt;</span>Eigen<span class="op">::</span>Lower<span class="op">&gt;())();</span></span>
<span id="cb2-28"><a href="#cb2-28"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> Eigen<span class="op">::</span>MatrixXd<span class="op">(</span>D<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-29"><a href="#cb2-29"></a></span>
<span id="cb2-30"><a href="#cb2-30"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"-----------to_ref test---------"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-31"><a href="#cb2-31"></a>    Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> E <span class="op">=</span> A <span class="op">*</span> A<span class="op">;</span></span>
<span id="cb2-32"><a href="#cb2-32"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> Eigen<span class="op">::</span>MatrixXd<span class="op">(</span>A<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-33"><a href="#cb2-33"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"   -------ans-------"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-34"><a href="#cb2-34"></a>    Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> F <span class="op">=</span> </span>
<span id="cb2-35"><a href="#cb2-35"></a>        stan<span class="op">::</span>math<span class="op">::</span>Block_sparse_lower<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>E<span class="op">),</span> <span class="kw">decltype</span><span class="op">(</span>B<span class="op">),</span><span class="kw">decltype</span><span class="op">(</span>C<span class="op">)&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">)();</span></span>
<span id="cb2-36"><a href="#cb2-36"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> Eigen<span class="op">::</span>MatrixXd<span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb2-37"><a href="#cb2-37"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After compilation, the output is</p>
<pre><code>-----------matrix test---------
0 0 0 0 0
0 0 0 4 0
0 0 3 0 0
0 2 0 0 0
1 0 0 0 0

1 2 3 4 5
1 2 3 4 5

1 1
1 1

   -------ans-------
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 3 0 0 0 0
0 2 0 0 0 0 0
1 0 0 0 0 0 0
1 2 3 4 5 1 0
1 2 3 4 5 1 1

-----------to_ref test---------
0 0 0 0 0
0 0 0 4 0
0 0 3 0 0
0 2 0 0 0
1 0 0 0 0

   -------ans-------
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 3 0 0 0 0
0 2 0 0 0 0 0
1 0 0 0 0 0 0
1 2 3 4 5 1 0
1 2 3 4 5 1 1
</code></pre>
<p>This is exactly what we expect! Hooray.</p>
<p>And that’s it. A symmetric 2x2 block sparse matrix in C++. Who knows what I’ll do next.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Or row if it’s row major<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Let’s anthropomorphize. I don’t want to write a blog about caches.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Drag name: Cache Mx<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>Until you’re rooting around a seventy page compiler error that really just means you forgot a typename on the final <code>return</code>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{simpson2024,
  author = {Simpson, Dan},
  title = {Random {C++} {Part} 1: {Building} a Block Sparse Matrix in
    {Eigen}},
  date = {2024-09-04},
  url = {https://dansblog.netlify.app/posts/2024-09-04-block-matrices/blocks.html},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-simpson2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Simpson, Dan. 2024. <span>“Random C++ Part 1: Building a Block Sparse
Matrix in Eigen.”</span> September 4, 2024. <a href="https://dansblog.netlify.app/posts/2024-09-04-block-matrices/blocks.html">https://dansblog.netlify.app/posts/2024-09-04-block-matrices/blocks.html</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/dansblog\.netlify\.app");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>