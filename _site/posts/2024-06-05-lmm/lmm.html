<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dan Simpson">
<meta name="dcterms.date" content="2024-06-05">
<meta name="description" content="Sure. You’ve been saying you were going to do this for year">

<title>Un garçon pas comme les autres (Bayes) - Getting fast linear mixed models into Stan; or I’m ok with C++ but C++ isn’t ok with me.</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="Un garçon pas comme les autres (Bayes) - Getting fast linear mixed models into Stan; or I’m ok with C++ but C++ isn’t ok with me.">
<meta property="og:description" content="Sure. You’ve been saying you were going to do this for year">
<meta property="og:image" content="https://dansblog.netlify.app/posts/2024-06-05-lmm/scooby.JPG">
<meta property="og:site_name" content="Un garçon pas comme les autres (Bayes)">
<meta name="twitter:title" content="Getting fast linear mixed models into Stan">
<meta name="twitter:description" content="Sure. You’ve been saying you were going to do this for year">
<meta name="twitter:image" content="https://dansblog.netlify.app/posts/2024-06-05-lmm/scooby.JPG">
<meta name="twitter:creator" content="@dan_p_simpson">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Un garçon pas comme les autres (Bayes)</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About this blog</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/dan_p_simpson"> <i class="bi bi-twitter" role="img" aria-label="twitter">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/dpsimpson"> <i class="bi bi-github" role="img" aria-label="github">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://dansblog.netlify.app"> <i class="bi bi-person-circle" role="img" aria-label="website">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Getting fast linear mixed models into Stan; or I’m ok with C++ but C++ isn’t ok with me.</h1>
                  <div>
        <div class="description">
          Sure. You’ve been saying you were going to do this for year
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">Stan</div>
                <div class="quarto-category">Sparse matrices</div>
                <div class="quarto-category">Autodiff</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p><a href="https://dansblog.netlify.app">Dan Simpson</a> </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 5, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#what-do-we-want-from-this" id="toc-what-do-we-want-from-this" class="nav-link active" data-scroll-target="#what-do-we-want-from-this">What do we want from this?</a></li>
  <li><a href="#attempt-1-a-general-formualtion" id="toc-attempt-1-a-general-formualtion" class="nav-link" data-scroll-target="#attempt-1-a-general-formualtion">Attempt 1: A general formualtion</a>
  <ul class="collapse">
  <li><a href="#marginalizing-out-u" id="toc-marginalizing-out-u" class="nav-link" data-scroll-target="#marginalizing-out-u">Marginalizing out <span class="math inline">\(u\)</span></a></li>
  <li><a href="#computing-pu-mid-alpha-beta-lambda-sigma-y" id="toc-computing-pu-mid-alpha-beta-lambda-sigma-y" class="nav-link" data-scroll-target="#computing-pu-mid-alpha-beta-lambda-sigma-y">Computing <span class="math inline">\(p(u \mid \alpha, \beta, \Lambda, \sigma, y)\)</span></a></li>
  <li><a href="#computing-palpha-beta-lambda-sigma-mid-y" id="toc-computing-palpha-beta-lambda-sigma-mid-y" class="nav-link" data-scroll-target="#computing-palpha-beta-lambda-sigma-mid-y">Computing <span class="math inline">\(p(\alpha, \beta, \Lambda, \sigma \mid y)\)</span></a></li>
  </ul></li>
  <li><a href="#attempt-2-a-less-flexible-model-thats-acutally-useful" id="toc-attempt-2-a-less-flexible-model-thats-acutally-useful" class="nav-link" data-scroll-target="#attempt-2-a-less-flexible-model-thats-acutally-useful">Attempt 2: A less flexible model that’s acutally useful</a></li>
  <li><a href="#c-plumbing-building-a-block-sparse-matrix" id="toc-c-plumbing-building-a-block-sparse-matrix" class="nav-link" data-scroll-target="#c-plumbing-building-a-block-sparse-matrix">C++ Plumbing: Building a block sparse matrix</a></li>
  <li><a href="#c-plumbing-a-partial-inverse" id="toc-c-plumbing-a-partial-inverse" class="nav-link" data-scroll-target="#c-plumbing-a-partial-inverse">C++ Plumbing: A partial inverse</a></li>
  <li><a href="#putting-the-derivatives-into-stan" id="toc-putting-the-derivatives-into-stan" class="nav-link" data-scroll-target="#putting-the-derivatives-into-stan">Putting the derivatives into Stan</a>
  <ul class="collapse">
  <li><a href="#differentiating-the-block-matrix" id="toc-differentiating-the-block-matrix" class="nav-link" data-scroll-target="#differentiating-the-block-matrix">Differentiating the block matrix</a></li>
  </ul></li>
  <li><a href="#c-plumbing-the-linear-solve" id="toc-c-plumbing-the-linear-solve" class="nav-link" data-scroll-target="#c-plumbing-the-linear-solve">C++ Plumbing: The linear solve</a></li>
  <li><a href="#adding-the-log-density-to-stan" id="toc-adding-the-log-density-to-stan" class="nav-link" data-scroll-target="#adding-the-log-density-to-stan">Adding the log-density to Stan</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>Sometimes when you want something done you need to do it yourself. And sometimes you are unemployed and need something to do that isn’t interviewing for jobs. And sure. Something that demonstrates my LLM prowess or my MLE capabilities would be a sensible thing to do. But fuck that. This blog is not for the sensible. This blog is for whims and regrets<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>And it is my whim to clean up one of my regrets: that I never got fast linear mixed models<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> into Stan.</p>
<p>There a pile of reasons for that. It’s a fuck-tonne of work that requires someone to actually go down the sparse matrix mines. Furthermore, it’s gotta be done in modern C++, which I think we can all agree is not a language that one casusually codes in only on occasion. C++ is a lifestyle. It is a calling.</p>
<p>But thankfully I am old as shit<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> and I have a PhD in numerical linear algebra. So I have more than a passing, if rusty familiarity with C++.</p>
<p>Over the years, I’ve contributed occasionally to the Stan codebase, but that was never my core contribution—I was an algorithm and methods man. Also the amount of time it would take me to add a feautre like sparse matrices was impossible to justify when I was an academic<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> or in industry<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>. But, as I said before, I am <em>unemployed</em> and don’t have to justify my time to anyone. So let’s fucking do this.</p>
<section id="what-do-we-want-from-this" class="level2">
<h2 class="anchored" data-anchor-id="what-do-we-want-from-this">What do we want from this?</h2>
<p>First of all, we need to set up some guidelines. I know that the vibe of this blog is jsut me writing text until I’m sick of it, which is (I am told), a lot later than most readers are sick of it. But this is actually a piece of software I want people to use, so I’m going to have at least some structure before I get fully on my bullshit.</p>
<p>So let’s look at what we want.</p>
<ol type="1">
<li><p>There should be functionality equivalent, at least, to the linear mixed effects models implemented in the R package <code>lme4</code>. This is a much lower bar than trying to match the various extensions to the basic formula implemented in things like <code>brms</code> or <code>INLA</code>. This should hopefully make the scope reasonable. Future extensions can be left for the future.</p></li>
<li><p>This should pre-compute as many of the common operations as possible. For example, when there is a lot of data, it does not make sense to compute <span class="math inline">\(X^TX\)</span> at every iteration of the dynamic HMC sampler. Unfortunately, the fundamental design decisions<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> underlying Stan do not let us cache information from iterations. Hence, we are going to need to pass all of these static quantities to the function. This <em>will</em> complicate the signature!</p></li>
<li><p>We want the function signature and the code to be as useable and maintainable as possible. Hence, we may want to deal with a simplified model rather than the most general possible case. It is better to have useable code that covers 90% of the cases than general code that is such a mess people simply want to cry.</p></li>
</ol>
<p>With these things in mind, our first trick will be to work out exactly how we want to formulate this problem. It’s going to turn out that our first attempt is pretty quickly going to break our third rule, so we will go with a slightly more restrictive model that still covers the majority of use cases.</p>
</section>
<section id="attempt-1-a-general-formualtion" class="level2">
<h2 class="anchored" data-anchor-id="attempt-1-a-general-formualtion">Attempt 1: A general formualtion</h2>
<p>Taking a leaf out of the Stan functions that are already built to speed up linear regression (<code>normal_id_lm_lpdf</code>), I’m going to go with the following eventual Stan syntax</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource {stan} number-lines code-with-copy"><code class="sourceCode"><span id="cb1-1"><a href="#cb1-1"></a>y ~ normal_id_lmm_lpdf(alpha, beta, X, Z, W, \Lambda, sigma);</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>to fit the model <span class="math display">\[\begin{align*}
y \mid \alpha, \beta,u,\sigma &amp;\sim N(\alpha + X\beta + Zu, \sigma^2 W)\\
u \mid \Lambda &amp;\sim N(0, \Lambda \Lambda^T).
\end{align*}\]</span> This is the same model (and the same notation) as the R package <code>lme4</code>, which is the gold standard for non-Bayesian GLMMs. If you want to dive into, eg, what <span class="math inline">\(Z\)</span> is, <a href="https://www.jstatsoft.org/article/view/v067i01">this paper</a> is an excelelnt resource.</p>
<p>(The canny reader might notice that I have lazily introduced broadcast semantics to make sure that eg the scalar <span class="math inline">\(\alpha\)</span> is interpereted as <span class="math inline">\(\alpha 1\)</span>, where <span class="math inline">\(1\)</span> is a vector of 1s.)</p>
<p>The user has free choice for priors on <span class="math inline">\(\beta\)</span>, <span class="math inline">\(\Lambda\)</span> and<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> <span class="math inline">\(\sigma\)</span>.</p>
<p>There is one thing that you might notice above: I am explicitly assuming that <span class="math inline">\(X\)</span>, <span class="math inline">\(Z\)</span>, and <span class="math inline">\(W\)</span> are <em>constants</em>. This is in contrast to the usual Stan thing where anything to the right of <code>~</code> can be a parameter. There are a bunch of reasons for this, but the main one is that I want to make this as fast as possible. And if those matrices are fixed I can do lots of sick tricks.</p>
<p>Just to close out, I want to zoom in on one more assumtion. I am assumeing that we are passed the Cholesky factorisation of the covariance matrix of <span class="math inline">\(u\)</span>. This is a good formulation for mixed effects models (and also aligns with the output you can get from <code>lme4</code> in R). It is not, however, the right formulation for spatial or temporal models, where you often want to specify the precision matrix<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> of <span class="math inline">\(u\)</span> instead. As much as I love it, I am shelving that application for the moment in favour of the more commonly used one.</p>
<section id="marginalizing-out-u" class="level3">
<h3 class="anchored" data-anchor-id="marginalizing-out-u">Marginalizing out <span class="math inline">\(u\)</span></h3>
<p>The way that we make this computationally efficient is to marginalise out the vector of random effects <span class="math inline">\(u\)</span>. This can be done efficiently using sparse linear algebra and the resulting marginal posterior <span class="math display">\[
p(\beta, \theta \mid y)
\]</span> is both lower-dimensional that the full posterior <span class="math inline">\(p(u,\beta,\theta\mid y)\)</span> and it has a considerably nicer geometry. This means that MCMC methods will be easier to tune and faster to run on the marginal posterior compared to the full posterior.</p>
<p>Furthermore, given a sample <span class="math inline">\((\beta_i, \theta_i)\)</span> from the marginal posterior, we can sample <span class="math display">\[
u_i \sim N(\mu(\beta_i, \theta_i), Q(\beta_i, \theta_i)^{-1})
\]</span> to recover the corresponding sample <span class="math inline">\((u_i, \beta_i, \theta_i)\)</span> from the full posterior. This conditional distriubiton is multivariate Gaussian and can be sampled efficently.</p>
<p>So let’s compute these things.</p>
<p>The core thing that any true Bayesian needs to know is that constants are not our problem. So lets dump them and write the joint distribuiton for the data and the parameters as <span class="math display">\[\begin{multline}
\log p(y, \alpha, \beta, u, \Lambda,\sigma) = K - N\log \sigma\\ - \frac{1}{2\sigma^2} (y-\alpha-X\beta-Zu)^TW(y-\alpha-X\beta-Zu)\\
- \frac{1}{2}u^T(\Lambda\Lambda^T)^{-1}u + \log p(\alpha, \beta, \Lambda,\sigma),
\end{multline}\]</span> where <span class="math inline">\(K\)</span> is our unimportant constant term and <span class="math inline">\(N\)</span> is the number of observations. I will be using <span class="math inline">\(K\)</span> for every constant because there is truly no point<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> in tracking them.</p>
</section>
<section id="computing-pu-mid-alpha-beta-lambda-sigma-y" class="level3">
<h3 class="anchored" data-anchor-id="computing-pu-mid-alpha-beta-lambda-sigma-y">Computing <span class="math inline">\(p(u \mid \alpha, \beta, \Lambda, \sigma, y)\)</span></h3>
<p>This joint distriubiton contains all of our information. We can get conditional distributions by just treating any term on the RHS of the conditioning bar as a constant. For example, <span class="math display">\[
\log p(u \mid y, \alpha, \beta, \sigma ) = K - \frac{1}{2}u^T(\sigma^{-2}Z^TWZ + (\Lambda\Lambda^T)^{-1})u + \frac{1}{\sigma^2}(y - \alpha-X\beta)^TWZu.
\]</span></p>
<p>If you’ve been doing this for long enough (or if you read the last post where I did this calculation), you’ll see that this is normal distribution with mean <span class="math display">\[
(\sigma^{-2}Z^TWZ + (\Lambda\Lambda^T)^{-1})^{-1}Z^TW(y - \alpha - X\beta)
\]</span> covariance matrix <span class="math display">\[
(\sigma^{-2}Z^TWZ + (\Lambda\Lambda^T)^{-1})^{-1}.
\]</span></p>
<p>It’s probably useful to clean up that covariance matrix bit to remove that inverse-of-an-inverse bullshit. The easiest way is to write it as <span class="math display">\[
\sigma^2\Lambda(\Lambda^TZ^TWZ\Lambda + \sigma^2 I)^{-1}\Lambda^T.
\]</span></p>
<p>The canny amongst you will notice that this is the covariance matrix of <span class="math inline">\(u = \Lambda w\)</span>, where <span class="math display">\[
w \sim N\left((\Lambda^TZ^TWZ\Lambda + I)^{-1}\Lambda^TZ^TW(y - \alpha - X\beta), \sigma^2 (\Lambda^TZ^TWZ\Lambda + \sigma^2 I)^{-1}\right).
\]</span></p>
<p>Looking at all of this, it’s pretty clear that it’s a lot nicer computationally to work with <span class="math inline">\(w\)</span> rather than <span class="math inline">\(u\)</span>, which is equivalent to writing the model as <span class="math display">\[
y \mid \alpha,\beta, w \sim N(\alpha + X\beta + Z\Lambda w, \sigma^2 W^{-1}),
\]</span> where <span class="math inline">\(w\sim N(0,I)\)</span>.</p>
<p>This reformulation is a consequence of how the random effect has been parameterized. If it was parameterized with its precsion matrix instead of its covariance, we wouldn’t need to do this.</p>
</section>
<section id="computing-palpha-beta-lambda-sigma-mid-y" class="level3">
<h3 class="anchored" data-anchor-id="computing-palpha-beta-lambda-sigma-mid-y">Computing <span class="math inline">\(p(\alpha, \beta, \Lambda, \sigma \mid y)\)</span></h3>
<p>So now we’ve got to do an integral. Luckliy, it’s Gaussian so we can do it. The trick with this part of the computation is to express the full conditional as <span class="math display">\[
\log p(u,\theta \mid y) = K - \frac{1}{2}(u - m)^T Q (u - m) + f(\theta),
\]</span> where I have defined <span class="math inline">\(\theta = (\alpha, \beta, \sigma, \Lambda)\)</span> because frankly I got sick of typing, <span class="math inline">\(f(\theta)\)</span> is all of the non-constant terms that don’t involve <span class="math inline">\(u\)</span>, <span class="math inline">\(m\)</span> is some vector, and <span class="math inline">\(Q\)</span> is some precision matrix. With this in hand, we can integrate out <span class="math inline">\(u\)</span> directly and get <span class="math display">\[
\log p(u,\theta \mid y) = K + \frac{1}{2}\log |Q| + \log p(\theta),
\]</span> by dint of the Gaussian integral being the only multivaraite integral I remember.</p>
<p>So how do we find this mystical <span class="math inline">\((m, Q)\)</span>? Well the godo news is that we have technically already done this to get the conditional distribution. Behind the scenes I added and subtracted <span class="math display">\[
\frac{1}{2}\mu_{u \mid y, \theta}^TQ_{u\mid y,\theta}\mu_{u \mid y, \theta},
\]</span> where <span class="math display">\[
\mu_{u \mid y, \theta} = Q_{u\mid y,\theta}^{-1}Z^T(y-\alpha - X\beta) = \Lambda(\sigma^{-2}\Lambda^TZ^TWZ\Lambda + I)^{-1}(y-\alpha -X\beta)
\]</span> is the mean of <span class="math inline">\(p(u \mid \theta, y)\)</span>, and <span class="math display">\[
Q_{u\mid y,\theta} = \sigma^{-2}Z^TWZ + (\Lambda \Lambda^T)^{-1}.
\]</span></p>
<p>This means that if we drop all of the terms in the joint that depend on <span class="math inline">\(u\)</span> and add <span class="math display">\[
\frac{1}{2}\log |\Lambda^TZ^TWZ\Lambda + I| - \log |
\Lambda| + \frac{1}{2} (y - \alpha - X\beta)^T\Lambda(\sigma^{-2}\Lambda^TZ^TWZ\Lambda + I)^{-1}\Lambda^T(y - \alpha - X\beta)
\]</span> to the leftovers, we will get the marginal distribution.</p>
<p>This leads to the marginal distribution <span class="math display">\[\begin{align*}
\log p(\alpha, \beta, \Lambda,\sigma \mid y) = K - N\log \sigma  
- \frac{1}{2\sigma^2} \alpha^T W \alpha  - \frac{1}{2\sigma^2} \beta^TX^TWX\beta&amp;
\\ + \frac{1}{\sigma^2}y^TW(\alpha + X\beta) - \frac{1}{\sigma^2} \alpha^TWX\beta &amp;\\
+ \frac{1}{2} (y-\alpha - X\beta)^T\Lambda(\sigma^{-2}\Lambda^TZ^T W Z\Lambda + I)^{-1}\Lambda^T(y - \alpha - X\beta)&amp;
\\ + \frac{1}{2}\log|\Lambda^TZ^TZ\Lambda + I| - \log|\Lambda|
+ \frac{1}{2}\log |Q_{u\mid \alpha,\beta,y}| + \log p(\alpha, \beta, \Lambda, \sigma).&amp;
\end{align*}\]</span></p>
<p>This is a fantastically ugly expression. We could clean it up a bit, but there’s one thing that it fails to do for us.</p>
<p>When doing any sort of linear regression, there computation of <span class="math inline">\(X^TX\)</span> and terms of its ilk is a potentially huge bottleneck, especially when the number of observations is large. Ideally, we would be able to pre-compute and pass all of the operations that involve <span class="math inline">\(X\)</span> so that we don’t have to repeat these potentially expensive computations. Sadly this is impossible here as we still need <span class="math inline">\(X\beta\)</span>. And even if it wasn’t, the number of things we would need to pass in is prohibative.</p>
</section>
</section>
<section id="attempt-2-a-less-flexible-model-thats-acutally-useful" class="level2">
<h2 class="anchored" data-anchor-id="attempt-2-a-less-flexible-model-thats-acutally-useful">Attempt 2: A less flexible model that’s acutally useful</h2>
<p>In a <a href="https://dansblog.netlify.app/posts/2022-03-22-a-linear-mixed-effects-model/a-linear-mixed-effects-model">previous post</a>, where I started off down this direction in JAX<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a>, I defined a version of the problem where I have a data likelihood <span class="math display">\[
y \mid u, \sigma \sim N(Au, \Sigma),
\]</span> and <span class="math inline">\(u\)</span> was defined as <span class="math display">\[
u \mid \theta \sim N(0, Q(\theta)^{-1}).
\]</span></p>
<p>This is a very computationally convenient way to write the problem, as it abstracts away the regression term and the random effects term(s) into <span class="math inline">\(A\)</span> and <span class="math inline">\(Q\)</span>, which are block sparse matrices.</p>
<p>In this case, we do not distinguish between <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span>, and <span class="math inline">\(u\)</span> as they are all (conditionally) Gaussian. This means that we can just pretend <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> are zero in the previous formulation and define<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a> <span class="math display">\[
\tilde{Z} = (Z\vdots X), \tilde{u} = \begin{pmatrix} u \\ \beta \end{pmatrix}.
\]</span> Then we have the model <span class="math display">\[
y \sim N(\tilde{Z} \tilde{u}, \sigma^2 W^{-1}),
\]</span> where <span class="math display">\[
\tilde{u} \sim N\left(0, \begin{pmatrix}\Lambda \Lambda^T &amp;0 \\0 &amp; \Sigma_\beta\end{pmatrix}\right).
\]</span></p>
<p>Unfortunately this is a) at a level of abstraction that is offputting to people who are thinking of using the method rather than just coding them, and b) making the key assumption that the priors on the regression coeffients are Gaussian (conditinal on <span class="math inline">\(\theta\)</span>).</p>
<p>This is one of those things that isn’t actually a huge loss of generality; the set of probability densities given by <span class="math display">\[
p(\beta) \propto \int_\Theta |\Sigma(\theta)|^{-1/2} \exp\left(-\frac{1}{2}\beta^T\Sigma(\theta)^{-1}\beta\right) \, p(\theta)\, d\theta
\]</span> is extremely expressive. So if you choose the correct <span class="math inline">\(p(\theta)\)</span> you can still have basically any prior<a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a> on the regression parameters you want.</p>
<p>This greatly simplifies our previous calculation and we get, after a bit of coersion, that <span class="math display">\[
\log p(y \mid \theta) = K  + \frac{1}{2}\log |Q_{\tilde{u}\mid y,\theta}(\theta)| + \frac{1}{2} y^TW\tilde{Z} \tilde{\mu}_{\tilde{u}\mid y,\theta} + \log p(\theta),
\]</span> where <span class="math display">\[
Q_{\tilde{u}\mid y,\theta}(\theta) = \tilde{Z}^TW\tilde{Z} = \begin{pmatrix}
\Lambda^TZ^TWZ\Lambda + I &amp; \Lambda^T Z^T WX \\ X^TWZ\Lambda &amp; X^TWX  + \Sigma_\beta^{-1}
\end{pmatrix}.
\]</span> The most important thing about this matrix is that all of the terms except <span class="math inline">\(\Lambda\)</span> and <span class="math inline">\(\Sigma_\beta\)</span> are constants and only need to be computed once.</p>
<p>The posterior mean for <span class="math inline">\(\tilde{u} \mid y,\theta\)</span> is given by the solution to <span class="math display">\[
\begin{pmatrix}
\Lambda^TZ^TWZ\Lambda + I &amp; \Lambda^T Z^T WX \\ X^TWZ\Lambda &amp; X^TWX  + \Sigma_\beta^{-1}
\end{pmatrix} \tilde{\mu}_{\tilde{u}\mid y,\theta} = \begin{pmatrix} \Lambda^T Z^TWy \\ X^TWy\end{pmatrix}.
\]</span></p>
<p>As the notation suggests, <span class="math display">\[
u \mid y, \theta \sim N(\mu_{\tilde{u}\mid y,\theta}(\theta), Q_{\tilde{u}\mid y,\theta}(\theta)^{-1}).
\]</span></p>
<p>Although they look quite different, both of these formulations are<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a> equivalent<a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a>.</p>
</section>
<section id="c-plumbing-building-a-block-sparse-matrix" class="level2">
<h2 class="anchored" data-anchor-id="c-plumbing-building-a-block-sparse-matrix">C++ Plumbing: Building a block sparse matrix</h2>
<p>The first thing that we need to do is build a block-sparse matrix. We know that this matrix is symmetric so we only need to store the lower-triangle.</p>
<p>In general, this is not the most difficult task in the world. We have <a href="https://dansblog.netlify.app/posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices#so-how-do-we-store-a-sparse-matrix">already talked about how we store sparse matrices</a> and, in particular, have had some fun with the Compressed Column Storage (CCS) scheme, which stores sparse matrices column-by-column. In the lingo, we call this <em>column major</em> storage.</p>
<p>When any array of numbers is stored in memory by a program, it is stored as a long vector and when you index into it (using something like <code>A[i,j]</code>) this is just some syntactic sugar for finding the correct value in that long vector.</p>
<p>Some languages, such as Fortran and Matlab, and libraries, such as <a href="https://gitlab.com/libeigen/eigen">Eigen</a>, store arrays in column major order. Others, like C/C++ and Python, use row-major storage. Stan is written in C++ but all of its linear algebra is done using Eigen, so we are going to use column-major storage.</p>
<p>It may seem catastrophically nerdy to be talking about internal storage orders for arrays in different languages, but I promise you this is <em>incredibly</em> important. If you want to write any sort of performant code, it’s extremely important that your algorithms are aligned with the internal storage order. That means that we need to prefer algorithms that run down columns of matrices over ones that run across rows.</p>
<p>This is because computers are clever and when you ask them for, eg <code>A[0,0]</code>, the CPU will actually load the first few entries of the 0th <em>column</em><a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a> of <code>A</code> in anticipation<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a> that you will need <code>A[0,1]</code> and its friends next. If you instead next ask for <code>A[1,0]</code>, the CPU has to throw its pre-loaded stuff out, reach out to some potentially distant memory and try again. When an array has a lot of rows, these cache misses<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a> noticably degrade the performance of a program.</p>
<p>All of that is to say that this is actually not too too hard to implement because we are just interleaving some contiguous chunks of a vector. While the main loop is pretty straightforward, C++ is truly a journey. So it’s gonna be like 100 lines of code.</p>
<p>The structure is</p>
<ol type="1">
<li><p>Allocate 3 arrays to store the outer index (which column?), the inner index (which row?), and the value.</p></li>
<li><p>Iterate through each column of the matrix, only storing the lower triangle.</p></li>
<li><p>Return an <code>Eigen::SparseMatrix&lt;double&gt;</code> built from those arrays.</p></li>
</ol>
<p>There are essentially two challenges in doing this. Firstly, the number of columns and then number of non-zeros are not known at compile time so we need to allocate dynamic memory on the heap. This is always a risky proposition in C++ as it’s pretty easy to screw up and end up with a memory leak. To get around this, I’m using the RAII (resource aquisition is instantiation) pattern, which basically encapsulates all the memory usage inside a functor, who’s call method return a sparse symmetric matrix.</p>
<p>The second challenge is that the Eigen API demands raw pointers. So this is going to have that good old fashioned <code>*ptr++</code> action.</p>
<p>Without further ado, here is the code. I’ll explain some key bits after.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/meta/is_eigen_sparse_base.hpp&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/meta/is_eigen.hpp&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/meta/is_stan_scalar.hpp&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/meta/base_type.hpp&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/err/check_size_match.hpp&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="pp">#include </span><span class="im">&lt;stan/math/prim/fun/to_ref.hpp&gt;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="pp">#include </span><span class="im">&lt;Eigen/SparseCore&gt;</span></span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="kw">namespace</span> stan <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="kw">namespace</span> math <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="kw">typedef</span> Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;::</span>StorageIndex StorageIndex<span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13"></a></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="co">// The require_ statements are defined in the first #include</span></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> SpMat<span class="op">,</span> <span class="kw">typename</span> EigMat1<span class="op">,</span> <span class="kw">typename</span> EigMat2<span class="op">,</span> </span>
<span id="cb2-16"><a href="#cb2-16"></a><span class="dt">require_eigen_sparse_base_t</span><span class="op">&lt;</span>SpMat<span class="op">&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">,</span></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="dt">require_all_eigen_t</span><span class="op">&lt;</span>EigMat1<span class="op">,</span> EigMat2<span class="op">&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">,</span></span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="dt">require_all_stan_scalar_t</span><span class="op">&lt;</span><span class="dt">base_type_t</span><span class="op">&lt;</span>SpMat<span class="op">&gt;,</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>                          <span class="dt">base_type_t</span><span class="op">&lt;</span>EigMat1<span class="op">&gt;,</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>                          <span class="dt">base_type_t</span><span class="op">&lt;</span>EigMat2<span class="op">&gt;&gt;*</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">&gt;</span>  </span>
<span id="cb2-21"><a href="#cb2-21"></a><span class="kw">class</span> Block_sparse_lower <span class="op">{</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>    <span class="co">/* </span></span>
<span id="cb2-23"><a href="#cb2-23"></a><span class="co">    A RAII functor class because Jesus hates memory leaks</span></span>
<span id="cb2-24"><a href="#cb2-24"></a><span class="co">    Make this encapsulate the whole thing.</span></span>
<span id="cb2-25"><a href="#cb2-25"></a><span class="co">    You may be asking why I'm using arrays and pointers</span></span>
<span id="cb2-26"><a href="#cb2-26"></a><span class="co">    like I'm writing in C, and the answer is </span></span>
<span id="cb2-27"><a href="#cb2-27"></a><span class="co">    "that's the interface to Map". The dream of the </span></span>
<span id="cb2-28"><a href="#cb2-28"></a><span class="co">    C-90 is alive and well in the eigen code base.</span></span>
<span id="cb2-29"><a href="#cb2-29"></a></span>
<span id="cb2-30"><a href="#cb2-30"></a><span class="co">    Anyway, `operator ()` returns a sparseMatrixMap</span></span>
<span id="cb2-31"><a href="#cb2-31"></a><span class="co">    */</span></span>
<span id="cb2-32"><a href="#cb2-32"></a>    <span class="kw">using</span> T <span class="op">=</span> <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">&lt;</span>SpMat<span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb2-33"><a href="#cb2-33"></a>   </span>
<span id="cb2-34"><a href="#cb2-34"></a>    StorageIndex<span class="op">*</span> <span class="va">m_outer</span><span class="op">;</span></span>
<span id="cb2-35"><a href="#cb2-35"></a>    StorageIndex<span class="op">*</span> <span class="va">m_inner</span><span class="op">;</span></span>
<span id="cb2-36"><a href="#cb2-36"></a>    T<span class="op">*</span> <span class="va">m_val</span><span class="op">;</span></span>
<span id="cb2-37"><a href="#cb2-37"></a>    StorageIndex <span class="va">m_cols</span><span class="op">;</span></span>
<span id="cb2-38"><a href="#cb2-38"></a>    StorageIndex <span class="va">m_nnz</span><span class="op">;</span></span>
<span id="cb2-39"><a href="#cb2-39"></a></span>
<span id="cb2-40"><a href="#cb2-40"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb2-41"><a href="#cb2-41"></a></span>
<span id="cb2-42"><a href="#cb2-42"></a>    Block_sparse_lower<span class="op">(</span></span>
<span id="cb2-43"><a href="#cb2-43"></a>        <span class="at">const</span> SpMat<span class="op">&amp;</span> top_left<span class="op">,</span> </span>
<span id="cb2-44"><a href="#cb2-44"></a>        <span class="at">const</span> EigMat1<span class="op">&amp;</span> bottom_left<span class="op">,</span> </span>
<span id="cb2-45"><a href="#cb2-45"></a>        <span class="at">const</span> EigMat2<span class="op">&amp;</span> bottom_right</span>
<span id="cb2-46"><a href="#cb2-46"></a>        <span class="op">)</span> </span>
<span id="cb2-47"><a href="#cb2-47"></a>    <span class="op">{</span></span>
<span id="cb2-48"><a href="#cb2-48"></a>        <span class="co">// only eval once</span></span>
<span id="cb2-49"><a href="#cb2-49"></a>        <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> tl_ref <span class="op">=</span> to_ref<span class="op">(</span>top_left<span class="op">);</span></span>
<span id="cb2-50"><a href="#cb2-50"></a>        <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> bl_ref <span class="op">=</span> to_ref<span class="op">(</span>bottom_left<span class="op">);</span></span>
<span id="cb2-51"><a href="#cb2-51"></a>        <span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> br_ref <span class="op">=</span> to_ref<span class="op">(</span>bottom_right<span class="op">);</span></span>
<span id="cb2-52"><a href="#cb2-52"></a></span>
<span id="cb2-53"><a href="#cb2-53"></a>        <span class="co">// Get sizes.</span></span>
<span id="cb2-54"><a href="#cb2-54"></a>        <span class="co">// NB tmp_nnz is an upper bound. Will only be correct if `top_left` is lower </span></span>
<span id="cb2-55"><a href="#cb2-55"></a>        <span class="co">// triangular. We will compute the real value on the fly.</span></span>
<span id="cb2-56"><a href="#cb2-56"></a>        <span class="at">const</span> StorageIndex ncols_tl <span class="op">=</span> tl_ref<span class="op">.</span>cols<span class="op">();</span></span>
<span id="cb2-57"><a href="#cb2-57"></a>        <span class="at">const</span> StorageIndex ncols_br <span class="op">=</span> br_ref<span class="op">.</span>cols<span class="op">();</span></span>
<span id="cb2-58"><a href="#cb2-58"></a>        <span class="at">const</span> StorageIndex tmp_nnz <span class="op">=</span> <span class="op">(</span>tl_ref<span class="op">.</span>nonZeros<span class="op">()</span> <span class="op">+</span> ncols_tl <span class="op">*</span> ncols_br </span>
<span id="cb2-59"><a href="#cb2-59"></a>                                        <span class="op">+</span> <span class="op">(</span>ncols_br <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> ncols_br <span class="op">/</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb2-60"><a href="#cb2-60"></a></span>
<span id="cb2-61"><a href="#cb2-61"></a>        <span class="co">// check sizes</span></span>
<span id="cb2-62"><a href="#cb2-62"></a>        check_size_match<span class="op">(</span><span class="st">"Block_sparse_lower"</span><span class="op">,</span> <span class="st">"Columns of "</span><span class="op">,</span> <span class="st">"top_left "</span><span class="op">,</span> tl_ref<span class="op">.</span>cols<span class="op">(),</span> <span class="st">"Columns of "</span><span class="op">,</span> <span class="st">"Bottom Left"</span><span class="op">,</span> bl_ref<span class="op">.</span>cols<span class="op">());</span></span>
<span id="cb2-63"><a href="#cb2-63"></a>        check_size_match<span class="op">(</span><span class="st">"Block_sparse_lower"</span><span class="op">,</span> <span class="st">"Rows of "</span><span class="op">,</span> <span class="st">"bottom-left "</span><span class="op">,</span> bl_ref<span class="op">.</span>rows<span class="op">(),</span> <span class="st">"Rows of "</span><span class="op">,</span> <span class="st">"Bottom-right"</span><span class="op">,</span> br_ref<span class="op">.</span>rows<span class="op">());</span></span>
<span id="cb2-64"><a href="#cb2-64"></a>        </span>
<span id="cb2-65"><a href="#cb2-65"></a>        <span class="co">// Allocate!</span></span>
<span id="cb2-66"><a href="#cb2-66"></a>        <span class="va">m_cols</span> <span class="op">=</span> ncols_tl <span class="op">+</span> ncols_br<span class="op">;</span></span>
<span id="cb2-67"><a href="#cb2-67"></a></span>
<span id="cb2-68"><a href="#cb2-68"></a>        <span class="va">m_outer</span> <span class="op">=</span> <span class="kw">new</span> StorageIndex<span class="op">[</span><span class="va">m_cols</span> <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-69"><a href="#cb2-69"></a>        <span class="va">m_outer</span><span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="op">*</span>top_left<span class="op">.</span>outerIndexPtr<span class="op">();</span></span>
<span id="cb2-70"><a href="#cb2-70"></a>        <span class="va">m_inner</span> <span class="op">=</span> <span class="kw">new</span> StorageIndex<span class="op">[</span>tmp_nnz<span class="op">];</span></span>
<span id="cb2-71"><a href="#cb2-71"></a>        <span class="va">m_val</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span>tmp_nnz<span class="op">];</span></span>
<span id="cb2-72"><a href="#cb2-72"></a>        </span>
<span id="cb2-73"><a href="#cb2-73"></a>        T<span class="op">*</span> p_val <span class="op">=</span> <span class="va">m_val</span><span class="op">;</span></span>
<span id="cb2-74"><a href="#cb2-74"></a>        StorageIndex<span class="op">*</span> p_inner <span class="op">=</span> <span class="va">m_inner</span><span class="op">;</span></span>
<span id="cb2-75"><a href="#cb2-75"></a>        StorageIndex out_nnz <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-76"><a href="#cb2-76"></a>        </span>
<span id="cb2-77"><a href="#cb2-77"></a>        <span class="cf">for</span> <span class="op">(</span>StorageIndex j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> ncols_tl<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-78"><a href="#cb2-78"></a>            StorageIndex col_cnt <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-79"><a href="#cb2-79"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">typename</span> SpMat<span class="op">::</span>InnerIterator it<span class="op">(</span>tl_ref<span class="op">,</span> j<span class="op">);</span> it<span class="op">;</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-80"><a href="#cb2-80"></a>                <span class="cf">if</span> <span class="op">(</span>it<span class="op">.</span>row<span class="op">()</span> <span class="op">&lt;</span> j<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span> <span class="co">// lower triangle only</span></span>
<span id="cb2-81"><a href="#cb2-81"></a>                <span class="op">*</span>p_val<span class="op">++</span> <span class="op">=</span> it<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb2-82"><a href="#cb2-82"></a>                <span class="op">*</span>p_inner<span class="op">++</span> <span class="op">=</span> it<span class="op">.</span>row<span class="op">();</span></span>
<span id="cb2-83"><a href="#cb2-83"></a>                <span class="op">++</span>out_nnz<span class="op">;</span></span>
<span id="cb2-84"><a href="#cb2-84"></a>                <span class="op">++</span>col_cnt<span class="op">;</span></span>
<span id="cb2-85"><a href="#cb2-85"></a>            <span class="op">}</span></span>
<span id="cb2-86"><a href="#cb2-86"></a></span>
<span id="cb2-87"><a href="#cb2-87"></a>            <span class="cf">for</span> <span class="op">(</span>StorageIndex i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> ncols_br<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-88"><a href="#cb2-88"></a>                <span class="op">*</span>p_val<span class="op">++</span> <span class="op">=</span> bl_ref<span class="op">.</span>coeff<span class="op">(</span>i<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb2-89"><a href="#cb2-89"></a>                <span class="op">*</span>p_inner<span class="op">++</span> <span class="op">=</span> ncols_tl <span class="op">+</span> i<span class="op">;</span></span>
<span id="cb2-90"><a href="#cb2-90"></a>                <span class="op">++</span>out_nnz<span class="op">;</span></span>
<span id="cb2-91"><a href="#cb2-91"></a>                <span class="op">++</span>col_cnt<span class="op">;</span></span>
<span id="cb2-92"><a href="#cb2-92"></a>            <span class="op">}</span></span>
<span id="cb2-93"><a href="#cb2-93"></a>        </span>
<span id="cb2-94"><a href="#cb2-94"></a>            <span class="va">m_outer</span><span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="va">m_outer</span><span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> col_cnt<span class="op">;</span></span>
<span id="cb2-95"><a href="#cb2-95"></a>        <span class="op">}</span></span>
<span id="cb2-96"><a href="#cb2-96"></a>        </span>
<span id="cb2-97"><a href="#cb2-97"></a>        <span class="cf">for</span> <span class="op">(</span>StorageIndex j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> ncols_br<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-98"><a href="#cb2-98"></a>            <span class="co">// only need lower triangle</span></span>
<span id="cb2-99"><a href="#cb2-99"></a>            <span class="cf">for</span> <span class="op">(</span>StorageIndex i <span class="op">=</span> j<span class="op">;</span> i <span class="op">&lt;</span> ncols_br<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-100"><a href="#cb2-100"></a>                <span class="op">*</span>p_val<span class="op">++</span> <span class="op">=</span> br_ref<span class="op">.</span>coeff<span class="op">(</span>i<span class="op">,</span>j<span class="op">);</span></span>
<span id="cb2-101"><a href="#cb2-101"></a>                <span class="op">*</span>p_inner<span class="op">++</span> <span class="op">=</span> ncols_tl <span class="op">+</span> i<span class="op">;</span></span>
<span id="cb2-102"><a href="#cb2-102"></a>                <span class="op">++</span>out_nnz<span class="op">;</span></span>
<span id="cb2-103"><a href="#cb2-103"></a>            <span class="op">}</span></span>
<span id="cb2-104"><a href="#cb2-104"></a>            <span class="va">m_outer</span><span class="op">[</span>ncols_tl<span class="op">+</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="va">m_outer</span><span class="op">[</span>ncols_tl <span class="op">+</span> j<span class="op">]</span> <span class="op">+</span> ncols_br <span class="op">-</span> j<span class="op">;</span></span>
<span id="cb2-105"><a href="#cb2-105"></a>        <span class="op">}</span></span>
<span id="cb2-106"><a href="#cb2-106"></a>        <span class="va">m_nnz</span> <span class="op">=</span> out_nnz<span class="op">;</span></span>
<span id="cb2-107"><a href="#cb2-107"></a>    <span class="op">}</span> <span class="co">// constructor</span></span>
<span id="cb2-108"><a href="#cb2-108"></a></span>
<span id="cb2-109"><a href="#cb2-109"></a>    <span class="op">~</span>Block_sparse_lower<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-110"><a href="#cb2-110"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_outer</span><span class="op">;</span></span>
<span id="cb2-111"><a href="#cb2-111"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_inner</span><span class="op">;</span></span>
<span id="cb2-112"><a href="#cb2-112"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_val</span><span class="op">;</span></span>
<span id="cb2-113"><a href="#cb2-113"></a>    <span class="op">}</span> <span class="co">// destructor</span></span>
<span id="cb2-114"><a href="#cb2-114"></a></span>
<span id="cb2-115"><a href="#cb2-115"></a>    Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="kw">operator</span> <span class="op">()</span> <span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-116"><a href="#cb2-116"></a>        <span class="cf">return</span> <span class="kw">typename</span> Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span>T<span class="op">&gt;::</span>Map<span class="op">(</span></span>
<span id="cb2-117"><a href="#cb2-117"></a>            <span class="va">m_cols</span><span class="op">,</span> </span>
<span id="cb2-118"><a href="#cb2-118"></a>            <span class="va">m_cols</span><span class="op">,</span></span>
<span id="cb2-119"><a href="#cb2-119"></a>            <span class="va">m_nnz</span><span class="op">,</span></span>
<span id="cb2-120"><a href="#cb2-120"></a>            <span class="va">m_outer</span><span class="op">,</span></span>
<span id="cb2-121"><a href="#cb2-121"></a>            <span class="va">m_inner</span><span class="op">,</span></span>
<span id="cb2-122"><a href="#cb2-122"></a>            <span class="va">m_val</span></span>
<span id="cb2-123"><a href="#cb2-123"></a>        <span class="op">);</span>   </span>
<span id="cb2-124"><a href="#cb2-124"></a>    <span class="op">}</span> <span class="co">//operator ()</span></span>
<span id="cb2-125"><a href="#cb2-125"></a><span class="op">};</span> <span class="co">// Block_sparse_lower</span></span>
<span id="cb2-126"><a href="#cb2-126"></a><span class="op">}</span> <span class="co">// namespace math</span></span>
<span id="cb2-127"><a href="#cb2-127"></a><span class="op">}</span> <span class="co">// namespace stan</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The first thing you probably noticed was all the templates. Templates are a beautiful<a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a> feature of C++ and pretty much all that bit just alllows us to have any matrix and sparse matrix from Eigen as long as they contain scalars (as opposed to autodiff variables). They also allow us to hack together a pre-C++20 version of <a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">concepts</a>, which is all of the <code>require_</code> statements.</p>
<p>Once we are actually in the class, it has three methods. The constructor takes in the three matrices, one sparse and two dense. It checks at compile time that they are all column-major and then starts doing its work. There’s nothing too exciting happening here. Some size checking, and then we run through the loop stacking the relevant vector parts onto each other.</p>
<p>The destructor frees the allocated memory (a core part of the RAII pattern).</p>
<p>Finally, we need to actually get access to this sparse matrix, which I implemented as a call operator. It returns a self-adjoint view (aka it will pretend to be symmetric when doing operations even though only the lower triangle is filled) of a <code>Map</code> of the three pointers. <code>Map</code>s are a nice way for Eigen to tell its internal <code>SparseMatrix</code> representation to look at the pieces of memory defined in this class when it is looking for inner indices, outer indices, or values. This doesn’t create a copy so it’s memory efficient.</p>
<p>So let’s test it. I’m going to run the following code .</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="pp">#include </span><span class="im">"sp_block.hpp"</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="pp">#include </span><span class="im">"Eigen/SparseCore"</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="pp">#include </span><span class="im">"Eigen/Dense"</span></span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"-----------matrix test---------"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>    <span class="dt">double</span> values<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="fl">1.</span><span class="op">,</span> <span class="fl">2.</span><span class="op">,</span> <span class="fl">3.</span><span class="op">,</span> <span class="fl">4.</span> <span class="op">};</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="dt">int</span> inner<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span> <span class="op">};</span> <span class="co">// nonzero row indices</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="dt">int</span> outer<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">4</span> <span class="op">};</span> <span class="co">// start index per column + 1 for last col</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> A <span class="op">=</span> Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;::</span>Map<span class="op">(</span></span>
<span id="cb3-13"><a href="#cb3-13"></a>        <span class="dv">5</span> <span class="co">/*rows*/</span><span class="op">,</span> <span class="dv">5</span> <span class="co">/*cols*/</span><span class="op">,</span> <span class="dv">4</span> <span class="co">/*nonzeros*/</span><span class="op">,</span> outer<span class="op">,</span> inner<span class="op">,</span> values<span class="op">);</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>    </span>
<span id="cb3-15"><a href="#cb3-15"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> Eigen<span class="op">::</span>MatrixXd<span class="op">(</span>A<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16"></a></span>
<span id="cb3-17"><a href="#cb3-17"></a>    Eigen<span class="op">::</span>Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">&gt;</span> B<span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>    B <span class="op">&lt;&lt;</span> <span class="fl">1.</span><span class="op">,</span><span class="fl">2.</span><span class="op">,</span><span class="fl">3.</span><span class="op">,</span><span class="fl">4.</span><span class="op">,</span><span class="fl">5.</span><span class="op">,</span><span class="fl">1.</span><span class="op">,</span><span class="fl">2.</span><span class="op">,</span><span class="fl">3.</span><span class="op">,</span><span class="fl">4.</span><span class="op">,</span><span class="fl">5.</span><span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> B <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>    Eigen<span class="op">::</span>Matrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">&gt;</span> C<span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21"></a>    C <span class="op">&lt;&lt;</span> <span class="fl">1.</span><span class="op">,</span><span class="fl">1.</span><span class="op">,</span><span class="fl">1.</span><span class="op">,</span><span class="fl">1.</span><span class="op">;</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> C <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-23"><a href="#cb3-23"></a>    </span>
<span id="cb3-24"><a href="#cb3-24"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"   -------ans-------"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25"></a>    Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> D <span class="op">=</span> </span>
<span id="cb3-26"><a href="#cb3-26"></a>        stan<span class="op">::</span>math<span class="op">::</span>Block_sparse_lower<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>A<span class="op">),</span> <span class="kw">decltype</span><span class="op">(</span>B<span class="op">),</span><span class="kw">decltype</span><span class="op">(</span>C<span class="op">)&gt;(</span></span>
<span id="cb3-27"><a href="#cb3-27"></a>            A<span class="op">.</span>triangularView<span class="op">&lt;</span>Eigen<span class="op">::</span>Lower<span class="op">&gt;(),</span> B<span class="op">,</span> C<span class="op">.</span>triangularView<span class="op">&lt;</span>Eigen<span class="op">::</span>Lower<span class="op">&gt;())();</span></span>
<span id="cb3-28"><a href="#cb3-28"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> Eigen<span class="op">::</span>MatrixXd<span class="op">(</span>D<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-29"><a href="#cb3-29"></a></span>
<span id="cb3-30"><a href="#cb3-30"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"-----------to_ref test---------"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-31"><a href="#cb3-31"></a>    Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> E <span class="op">=</span> A <span class="op">*</span> A<span class="op">;</span></span>
<span id="cb3-32"><a href="#cb3-32"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> Eigen<span class="op">::</span>MatrixXd<span class="op">(</span>A<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-33"><a href="#cb3-33"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"   -------ans-------"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-34"><a href="#cb3-34"></a>    Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> F <span class="op">=</span> </span>
<span id="cb3-35"><a href="#cb3-35"></a>        stan<span class="op">::</span>math<span class="op">::</span>Block_sparse_lower<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>E<span class="op">),</span> <span class="kw">decltype</span><span class="op">(</span>B<span class="op">),</span><span class="kw">decltype</span><span class="op">(</span>C<span class="op">)&gt;(</span>A<span class="op">,</span> B<span class="op">,</span> C<span class="op">)();</span></span>
<span id="cb3-36"><a href="#cb3-36"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> Eigen<span class="op">::</span>MatrixXd<span class="op">(</span>F<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-37"><a href="#cb3-37"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>After compilation, the output is</p>
<pre><code>-----------matrix test---------
0 0 0 0 0
0 0 0 4 0
0 0 3 0 0
0 2 0 0 0
1 0 0 0 0

1 2 3 4 5
1 2 3 4 5

1 1
1 1

   -------ans-------
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 3 0 0 0 0
0 2 0 0 0 0 0
1 0 0 0 0 0 0
1 2 3 4 5 1 0
1 2 3 4 5 1 1

-----------to_ref test---------
0 0 0 0 0
0 0 0 4 0
0 0 3 0 0
0 2 0 0 0
1 0 0 0 0

   -------ans-------
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 3 0 0 0 0
0 2 0 0 0 0 0
1 0 0 0 0 0 0
1 2 3 4 5 1 0
1 2 3 4 5 1 1
</code></pre>
<p>This is exactly what we expect! Hooray.</p>
</section>
<section id="c-plumbing-a-partial-inverse" class="level2">
<h2 class="anchored" data-anchor-id="c-plumbing-a-partial-inverse">C++ Plumbing: A partial inverse</h2>
<p>In order to compute the relevant derivatives, we need access to the elements of <span class="math inline">\(Q^{-1}\)</span> that correspond to the non-zero elements of <span class="math inline">\(Q\)</span>. While it seems like this should be extremely expensive, it is cheap and straightforward to get these elements from the Cholesky triangle of <span class="math inline">\(Q\)</span>.</p>
<p>For a description of this algorithm and a background on why this is necessary, look at the <a href="https://dansblog.netlify.app/posts/2022-05-20-to-catch-a-derivative-first-youve-got-to-think-like-a-derivative/to-catch-a-derivative-first-youve-got-to-think-like-a-derivative#computing-the-partial-inverse">previous post</a> where I derived it and implemented it in Python.</p>
<p>The C++ implementation (which is strongly indebted to Finn Lindgren!) is similar, but uses the Eigen iterators.</p>
<p>Essentially, we need to implement the following pseudocode.</p>
<pre><code> for i = n-1, ..., 0
   for j = n-1, ..., i
   if (L[j,i] not known to be 0)
      Sigma[j,i] = Sigma[i,j] = (I(i==j)/L[i,i] 
        - sum_{k=i+1}^{n-1} L[k,i] Sigma[k,j] ) / L[i,i]</code></pre>
<p>Using iterators to do this is, perhaps, a bit annoying, but it is very safe. It might look like you need three iterators to do this, but we atually need four. Because the matrix is stored in Column-major order, we are going to need a new iterator for every distinct column index. In this case, that is 1. A reverse iterator going up column <code>i</code> of <code>Sigma</code> 2. A reverse iterator going up column <code>i</code> of <code>L</code> 3. A reverse iterator going up colunn <code>j</code> of <code>Sigma</code> 4. A reverse iterator going up column <code>i</code> in sync with iterator 3.</p>
<p>The C++ code is pretty straightforward after that, you just need to keep your iterators in sync. One wrinkle that I forgot about the first time I coded this is that there are a few things that I need to be true: firstly, I need the output to be the lower-triangle of a symmetric matrix, and secondly I need that matrix to have the same sparsity pattern as <span class="math inline">\(Q\)</span>. To do this, I wrote another RAII class, mainly because if I’m going to manipulate raw pointers I’m gonna want some safety.</p>
<p>The code is below</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="pp">#include </span><span class="im">&lt;Eigen/SparseCore&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="pp">#include </span><span class="im">&lt;Eigen/SparseCholesky&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">namespace</span> stan <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">namespace</span> math <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="kw">typedef</span> Eigen<span class="op">::</span>SparseMatrix<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;::</span>StorageIndex StorageIndex<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> SpMat<span class="op">&gt;</span> <span class="kw">class</span> MatchPattern <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="kw">using</span> T <span class="op">=</span> <span class="kw">typename</span> <span class="dt">base_type</span><span class="op">&lt;</span>SpMat<span class="op">&gt;::</span>type<span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    StorageIndex<span class="op">*</span> <span class="va">m_outer</span><span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>    StorageIndex<span class="op">*</span> <span class="va">m_inner</span><span class="op">;</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    T<span class="op">*</span> <span class="va">m_val</span><span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>    StorageIndex <span class="va">m_cols</span><span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>    StorageIndex <span class="va">m_nnz</span><span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15"></a></span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a>    MatchPattern<span class="op">(</span><span class="at">const</span> SpMat<span class="op">&amp;</span> A<span class="op">,</span> <span class="at">const</span> SpMat<span class="op">&amp;</span> pattern<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>        <span class="va">m_cols</span> <span class="op">=</span> pattern<span class="op">.</span>cols<span class="op">();</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>        <span class="va">m_nnz</span> <span class="op">=</span> pattern<span class="op">.</span>nonZeros<span class="op">();</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>        <span class="va">m_outer</span> <span class="op">=</span> pattern<span class="op">.</span>outerIndexPtr<span class="op">();</span> </span>
<span id="cb6-22"><a href="#cb6-22"></a>        <span class="va">m_inner</span> <span class="op">=</span> </span>
<span id="cb6-23"><a href="#cb6-23"></a>        <span class="va">m_val</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span><span class="va">m_nnz</span><span class="op">];</span></span>
<span id="cb6-24"><a href="#cb6-24"></a></span>
<span id="cb6-25"><a href="#cb6-25"></a>        T<span class="op">*</span> valptr <span class="op">=</span> <span class="va">m_val</span><span class="op">;</span></span>
<span id="cb6-26"><a href="#cb6-26"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="va">m_cols</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-27"><a href="#cb6-27"></a>            <span class="kw">typename</span> SpMat<span class="op">::</span>InnerIterator Acol<span class="op">(</span>A<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb6-28"><a href="#cb6-28"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">typename</span> SpMat<span class="op">::</span>InnerIterator pattern_col<span class="op">(</span>pattern<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb6-29"><a href="#cb6-29"></a>                pattern_col<span class="op">;</span> <span class="op">++</span>pattern_col<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-30"><a href="#cb6-30"></a>                    <span class="cf">while</span> <span class="op">(</span>Acol <span class="op">&amp;</span> <span class="op">(</span>Acol<span class="op">.</span>row<span class="op">()</span> <span class="op">&lt;</span> pattern_col<span class="op">.</span>row<span class="op">())){</span></span>
<span id="cb6-31"><a href="#cb6-31"></a>                        <span class="op">++</span>Acol<span class="op">;</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>                    <span class="op">}</span></span>
<span id="cb6-33"><a href="#cb6-33"></a>                    valptr<span class="op">++</span> <span class="op">=</span> Acol<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb6-34"><a href="#cb6-34"></a>                    <span class="op">++</span>Acol<span class="op">;</span></span>
<span id="cb6-35"><a href="#cb6-35"></a>                <span class="op">}</span></span>
<span id="cb6-36"><a href="#cb6-36"></a>        <span class="op">}</span></span>
<span id="cb6-37"><a href="#cb6-37"></a>    <span class="op">}</span></span>
<span id="cb6-38"><a href="#cb6-38"></a></span>
<span id="cb6-39"><a href="#cb6-39"></a>    <span class="op">~</span>MatchPattern<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-40"><a href="#cb6-40"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">m_val</span><span class="op">;</span></span>
<span id="cb6-41"><a href="#cb6-41"></a>    <span class="op">}</span></span>
<span id="cb6-42"><a href="#cb6-42"></a></span>
<span id="cb6-43"><a href="#cb6-43"></a>    SpMat <span class="kw">operator</span> <span class="op">()</span> <span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-44"><a href="#cb6-44"></a>        <span class="cf">return</span> <span class="kw">typename</span> SpMat<span class="op">::</span>Map<span class="op">(</span></span>
<span id="cb6-45"><a href="#cb6-45"></a>            <span class="va">m_cols</span><span class="op">,</span></span>
<span id="cb6-46"><a href="#cb6-46"></a>            <span class="va">m_cols</span><span class="op">,</span></span>
<span id="cb6-47"><a href="#cb6-47"></a>            <span class="va">m_nnz</span><span class="op">,</span></span>
<span id="cb6-48"><a href="#cb6-48"></a>            <span class="va">m_inner</span><span class="op">,</span></span>
<span id="cb6-49"><a href="#cb6-49"></a>            <span class="va">m_val</span></span>
<span id="cb6-50"><a href="#cb6-50"></a>        <span class="op">);</span></span>
<span id="cb6-51"><a href="#cb6-51"></a>    <span class="op">}</span></span>
<span id="cb6-52"><a href="#cb6-52"></a><span class="op">};</span></span>
<span id="cb6-53"><a href="#cb6-53"></a></span>
<span id="cb6-54"><a href="#cb6-54"></a></span>
<span id="cb6-55"><a href="#cb6-55"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> SpChol<span class="op">,</span> <span class="kw">typename</span> SpMat<span class="op">&gt;</span></span>
<span id="cb6-56"><a href="#cb6-56"></a><span class="kw">typename</span> SpChol<span class="op">::</span>MatrixType partial_inverse<span class="op">(</span></span>
<span id="cb6-57"><a href="#cb6-57"></a>    <span class="at">const</span> SpChol<span class="op">&amp;</span> llt<span class="op">,</span></span>
<span id="cb6-58"><a href="#cb6-58"></a>    <span class="at">const</span> SpMat<span class="op">&amp;</span> Q</span>
<span id="cb6-59"><a href="#cb6-59"></a><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-60"><a href="#cb6-60"></a>    <span class="kw">typedef</span> <span class="kw">typename</span> SpMat<span class="op">::</span>ReverseInnerIterator reverse_it<span class="op">;</span></span>
<span id="cb6-61"><a href="#cb6-61"></a>    StorageIndex ncols <span class="op">=</span> llt<span class="op">.</span>cols<span class="op">();</span></span>
<span id="cb6-62"><a href="#cb6-62"></a>    SpMat Qinv <span class="op">=</span> llt<span class="op">.</span>matrixL<span class="op">().</span><span class="kw">template</span> selfAdjointView<span class="op">();</span></span>
<span id="cb6-63"><a href="#cb6-63"></a></span>
<span id="cb6-64"><a href="#cb6-64"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> ncols <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-65"><a href="#cb6-65"></a>        reverse_it QinvcolI<span class="op">(</span>Qinv<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb6-66"><a href="#cb6-66"></a>        <span class="cf">for</span> <span class="op">(</span>reverse_it LcolI_slow<span class="op">(</span>llt<span class="op">.</span>matrixL<span class="op">(),</span> i<span class="op">);</span> LcolI_slow<span class="op">;</span> <span class="op">--</span>LcolI_slow<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-67"><a href="#cb6-67"></a>            <span class="co">// inner sum iterators</span></span>
<span id="cb6-68"><a href="#cb6-68"></a>            reverse_it LcolI<span class="op">(</span>llt<span class="op">.</span>matrixL<span class="op">(),</span> i<span class="op">);</span></span>
<span id="cb6-69"><a href="#cb6-69"></a>            reverse_it QinvcolJ<span class="op">(</span>Qinv<span class="op">,</span> LcolI_slow<span class="op">.</span>row<span class="op">());</span></span>
<span id="cb6-70"><a href="#cb6-70"></a>            </span>
<span id="cb6-71"><a href="#cb6-71"></a>            <span class="co">// Initialize Qinv[j,i]</span></span>
<span id="cb6-72"><a href="#cb6-72"></a>            QinvcolI<span class="op">.</span>valueRef<span class="op">()</span> <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb6-73"><a href="#cb6-73"></a></span>
<span id="cb6-74"><a href="#cb6-74"></a>            <span class="co">// Inner-most sum</span></span>
<span id="cb6-75"><a href="#cb6-75"></a>            <span class="cf">while</span> <span class="op">(</span>LcolI<span class="op">.</span>row<span class="op">()</span> <span class="op">&gt;</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-76"><a href="#cb6-76"></a>                <span class="co">// First up, sync the iterators</span></span>
<span id="cb6-77"><a href="#cb6-77"></a>                <span class="cf">while</span> <span class="op">(</span> QinvcolJ <span class="op">&amp;</span> <span class="op">(</span>LcolI<span class="op">.</span>row<span class="op">()</span> <span class="op">&lt;</span> QinvcolJ<span class="op">.</span>row<span class="op">())){</span></span>
<span id="cb6-78"><a href="#cb6-78"></a>                    <span class="op">--</span>QinvcolJ<span class="op">;</span></span>
<span id="cb6-79"><a href="#cb6-79"></a>                <span class="op">}</span></span>
<span id="cb6-80"><a href="#cb6-80"></a>                <span class="cf">if</span> <span class="op">(</span>QinvcolJ <span class="op">&amp;</span> <span class="op">(</span>QinvcolJ<span class="op">.</span>row<span class="op">()</span> <span class="op">==</span> LcolI<span class="op">.</span>row<span class="op">()))</span> <span class="op">{</span></span>
<span id="cb6-81"><a href="#cb6-81"></a>                    QinvcolI<span class="op">.</span>valueRef<span class="op">()</span> <span class="op">-=</span> LcolI<span class="op">.</span>value<span class="op">()</span> <span class="op">*</span> QinvcolJ<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb6-82"><a href="#cb6-82"></a>                    <span class="op">--</span>QinvcolJ<span class="op">;</span></span>
<span id="cb6-83"><a href="#cb6-83"></a>                <span class="op">}</span></span>
<span id="cb6-84"><a href="#cb6-84"></a>                <span class="op">--</span>LcolI<span class="op">;</span></span>
<span id="cb6-85"><a href="#cb6-85"></a>            <span class="op">}</span></span>
<span id="cb6-86"><a href="#cb6-86"></a>            <span class="co">// At this point LcolI is the diagonal value</span></span>
<span id="cb6-87"><a href="#cb6-87"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> LcolI<span class="op">.</span>row<span class="op">())</span> <span class="op">{</span></span>
<span id="cb6-88"><a href="#cb6-88"></a>                QinvcolI<span class="op">.</span>vaueRef<span class="op">()</span> <span class="op">+=</span>  <span class="dv">1</span><span class="op">/</span> LcolI<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb6-89"><a href="#cb6-89"></a>                QinvcolI<span class="op">.</span>vaueRef<span class="op">()</span> <span class="op">/=</span>  LcolI<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb6-90"><a href="#cb6-90"></a>            <span class="op">}</span> <span class="cf">else</span><span class="op">{</span></span>
<span id="cb6-91"><a href="#cb6-91"></a>                QinvcolI<span class="op">.</span>vaueRef<span class="op">()</span> <span class="op">/=</span>  LcolI<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb6-92"><a href="#cb6-92"></a>                <span class="co">// Set Qinv[i,j] = Qinv[j,i]</span></span>
<span id="cb6-93"><a href="#cb6-93"></a>                <span class="cf">while</span> <span class="op">(</span>QinvcolJ<span class="op">.</span>row<span class="op">()</span> <span class="op">&gt;</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-94"><a href="#cb6-94"></a>                    <span class="op">--</span>QinvcolJ<span class="op">;</span></span>
<span id="cb6-95"><a href="#cb6-95"></a>                <span class="op">}</span></span>
<span id="cb6-96"><a href="#cb6-96"></a>                QinvcolJ<span class="op">.</span>valRef<span class="op">()</span> <span class="op">=</span> QinvcolI<span class="op">.</span>value<span class="op">();</span></span>
<span id="cb6-97"><a href="#cb6-97"></a>            <span class="op">}</span></span>
<span id="cb6-98"><a href="#cb6-98"></a>        <span class="op">}</span></span>
<span id="cb6-99"><a href="#cb6-99"></a>        <span class="op">--</span>QinvcolI<span class="op">;</span></span>
<span id="cb6-100"><a href="#cb6-100"></a>    <span class="op">}</span></span>
<span id="cb6-101"><a href="#cb6-101"></a>    <span class="co">// Undo the permuatation</span></span>
<span id="cb6-102"><a href="#cb6-102"></a>    Qinv <span class="op">=</span> Qinv<span class="op">.</span>twistedBy<span class="op">(</span>llt<span class="op">.</span>permutationP<span class="op">().</span>inverse<span class="op">());</span></span>
<span id="cb6-103"><a href="#cb6-103"></a></span>
<span id="cb6-104"><a href="#cb6-104"></a>    <span class="co">// Return the non-zero elements of Qinv corresponding to the non-zero</span></span>
<span id="cb6-105"><a href="#cb6-105"></a>    <span class="co">// elements of Q</span></span>
<span id="cb6-106"><a href="#cb6-106"></a>    <span class="cf">return</span> MatchPattern<span class="op">(</span>Qinv<span class="op">,</span> Q<span class="op">)();</span></span>
<span id="cb6-107"><a href="#cb6-107"></a></span>
<span id="cb6-108"><a href="#cb6-108"></a><span class="op">}</span></span>
<span id="cb6-109"><a href="#cb6-109"></a></span>
<span id="cb6-110"><a href="#cb6-110"></a><span class="op">}</span> <span class="co">// namespace math</span></span>
<span id="cb6-111"><a href="#cb6-111"></a><span class="op">}</span> <span class="co">// namespace stan</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You’ll probably notice that there are far fewer template shennigans here than in the block matrix code. That is because this only needs to work with scalar types and doesn’t need to be part of the <code>math</code> API. If needed, I guess we could always work out what teh derivitave is and implement its reverse-mode specialization, but frankly why<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a> bother.</p>
<p><strong>Do some testing</strong></p>
</section>
<section id="putting-the-derivatives-into-stan" class="level2">
<h2 class="anchored" data-anchor-id="putting-the-derivatives-into-stan">Putting the derivatives into Stan</h2>
<p>The most important thing about the Stan math library from a user perspective is that its functions are <em>differentiable</em>. The only way to make this true is to specialize the functions so that they behave correctly when touched by and autodiff variable. In Stan math, these are called <code>var</code>s. These have two important member functions <code>var.val()</code>, which returns its variable and <code>var.adj()</code>, which returns its adjoint.</p>
<p>This is not really the place to go through how autodiff works. I recommend <a href="https://arxiv.org/abs/1811.05031">Charles’ review</a>, or for more Stan-specific information we have the <a href="https://arxiv.org/pdf/1509.07164">old paper</a> or this <a href="https://blog.mc-stan.org/2020/11/23/thinking-about-automatic-differentiation-in-fun-new-ways/">blog post describing the most recent implementation of autodiff in Stan math</a>.</p>
<p>But the very very very short version is that if we want to backward differentiate the formula</p>
<pre><code>z = f(x, y)</code></pre>
<p>we need to update</p>
<pre><code>x.adj() += df_dxt * z.adj()
y.adj() += df_dyt * z.adj()</code></pre>
<p>where the variable <code>df_dxt</code> is the transpose of the Jacobian matrix.</p>
<p>We need to compute the derivative of the log-determinant (which involves the partial inverse above), the derivative of the linear solve used to compute the mean, and the derivative of the blocking operation.</p>
<p>The reason that we need to explicitly consider the blocking operation is that we are interested in the adjoint <span class="math inline">\(\bar \Lambda\)</span>, but when we differentiate the log-determinant and the linear solve, we will be computing <span class="math inline">\(\bar Q\)</span>. So we need to work out the link.</p>
<p>For instance, we need the derivative of <span class="math display">\[
\log \left|\begin{pmatrix}
\Lambda^TZ^TWZ\Lambda + I &amp; \Lambda^T Z^T WX \\ X^TWZ\Lambda &amp; X^TWX  + \Sigma_\beta^{-1}
\end{pmatrix}\right|
\]</span> with respect to <span class="math inline">\(\Lambda\)</span>.</p>
<p>To do this we will break this into two steps (in pesudocode):</p>
<pre><code>Q = BlockMatrix(Lambda.T* A * Lambda + I, Lambda.T * B, C)
log_det = log(det(Q))</code></pre>
<p>where <code>A</code>, <code>B</code>, and <code>C</code> are constant matrices. The reverse-mode autodiff procedure would then be</p>
<pre><code>Q.adj() -= partial_inverse(Q) * log_det.adj()
Lambda.adj() += [derivative] * [adjoint of the block matrix] </code></pre>
<p>So we need to work otu what that second line actually is!</p>
<section id="differentiating-the-block-matrix" class="level3">
<h3 class="anchored" data-anchor-id="differentiating-the-block-matrix">Differentiating the block matrix</h3>
<p>In order to do this, we need to work from first principles. We can do this using the notation and concepts from Mike Giles’ <a href="https://people.maths.ox.ac.uk/gilesm/files/NA-08-01.pdf.">fabulous paper</a></p>
<p>The adjoints <span class="math inline">\(\bar X\)</span> and <span class="math inline">\(\bar Y\)</span> of the equation <span class="math inline">\(Z = f(X,Y)\)</span> satisfy <span class="math display">\[
\operatorname{tr}\left(\bar{Z}^TdZ\right) = \operatorname{tr}\left(\bar{X}^TdX\right) + \operatorname{tr}\left(\bar{Y}^TdY\right),
\]</span> where <span class="math inline">\(\bar{X}\)</span> and <span class="math inline">\(\bar{Y}\)</span> going to depend on <span class="math inline">\(f\)</span> and <span class="math inline">\(\bar{C}\)</span>. The order is the reverse of evaluation order, which gives this mode of autodiff its name. In fact, we can do a lil maths and get <span class="math display">\[
\bar{X} = \frac{\partial f}{\partial X}^T \bar{Z},
\]</span> where <span class="math inline">\(\frac{\partial f}{\partial X}\)</span> is the Jacobian of <span class="math inline">\(f\)</span> wrt <span class="math inline">\(X\)</span>.</p>
<p>To get the update rule for <span class="math inline">\(\bar{\Lambda}\)</span> wrt <span class="math inline">\(\bar Q\)</span>, we use the definition of the adjoint <span class="math display">\[
\operatorname{tr}(\bar{Q}^TdQ) = \operatorname{tr}(\bar{\Lambda}d\Lambda).
\]</span></p>
<p>We know that <span class="math display">\[
dQ = \begin{pmatrix} (d\Lambda)^T Z^TWZ\Lambda + \Lambda^TZ^TWZd\Lambda &amp; (d\Lambda)^TZ^TWX \\ X^TWZd\Lambda &amp; 0 \end{pmatrix},
\]</span> which means we need to calculate <span class="math display">\[
\operatorname{tr}\left[\begin{pmatrix}
\bar{Q}_{11} &amp; \bar{Q}_{21}^T \\ \bar{Q}_{21} &amp; \bar{Q}_{22}
\end{pmatrix}^T\begin{pmatrix} (d\Lambda)^T Z^TWZ\Lambda + \Lambda^TZ^TWZd\Lambda &amp; (d\Lambda)^TZ^TWX \\ X^TWZd\Lambda &amp; 0 \end{pmatrix}\right].
\]</span> Some quick matrix multiplication and the cyclical property of the trace gives <span class="math display">\[
\operatorname{tr}(\bar{Q}^TdQ) = \operatorname{tr}\left(\right).
\]</span> After some cyclical rearrangeing, we get <span class="math display">\[
\operatorname{tr}(\bar{Q}^TdQ) = \operatorname{tr}\left[2\left(Z^TWZ\Lambda \bar{Q}_{11} + Z^TWX\bar{Q}_{{21}} \right)^Td\Lambda\right]
\]</span> and hence <span class="math display">\[
\bar \Lambda = Z^TWZ\Lambda \bar{Q}_{11} + Z^TWX\bar{Q}_{{21}}
\]</span></p>
<p>In order to compute this, we need to <em>un-block</em> our block matrix. This will, once again, just be a bunch of looping through iterators and buiilding <code>Eigen::Map</code>s.</p>
</section>
</section>
<section id="c-plumbing-the-linear-solve" class="level2">
<h2 class="anchored" data-anchor-id="c-plumbing-the-linear-solve">C++ Plumbing: The linear solve</h2>
<p>The final primitive that we need to implement is the linear solve. One way to do this would be to autodiff directly through the Cholesky factorisation and the triangular solve. But instead, we note that if <span class="math inline">\(c = A^{-1}b\)</span>, then<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a> <span class="math display">\[
dc = A^{-1}db + A^{-1}dAc
\]</span> and thus <span class="math display">\[
\operatorname{tr}(\bar{c}^Tdc) = \operatorname{tr}((A^{-1}\bar{c})^Tdb) - \operatorname{tr}(c\bar{c}^TA^{-1}dA)
\]</span> and so we get the adjoints <span class="math display">\[
\bar{b} = A^{-1}\bar{c}, \qquad \bar{A} = - A^{-1}\bar{c}c^T = -\bar{b}c^T,
\]</span> where once again if <span class="math inline">\(A\)</span> is sparse then we only need to track the elements of <span class="math inline">\(\bar{A}\)</span> that correspond to the non-zero values of <span class="math inline">\(A\)</span>.</p>
<p>This should be fairly simple to implement: the only tricky part is making sure that we have a mechanism to only get the sparse lower triangle of <span class="math inline">\(\bar{A}\)</span>.</p>
<p>This problem is extremely similar to <code>MatchPattern</code> defined above, so let’s just add a new constructor to that class.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource cpp number-lines code-with-copy"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a>MatchPattern<span class="op">(</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>    <span class="at">const</span> <span class="kw">typename</span> Eigen<span class="op">::</span>Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> b<span class="op">,</span> </span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="at">const</span> <span class="kw">typename</span> Eigen<span class="op">::</span>Vector<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> c<span class="op">,</span> </span>
<span id="cb11-4"><a href="#cb11-4"></a>    <span class="at">const</span> SpMat<span class="op">&amp;</span> pattern</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="va">m_cols</span> <span class="op">=</span> pattern<span class="op">.</span>cols<span class="op">();</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="va">m_nnz</span> <span class="op">=</span> pattern<span class="op">.</span>nonZeros<span class="op">();</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="va">m_outer</span> <span class="op">=</span> pattern<span class="op">.</span>outerIndexPtr<span class="op">();</span> </span>
<span id="cb11-9"><a href="#cb11-9"></a>    <span class="va">m_inner</span> <span class="op">=</span> </span>
<span id="cb11-10"><a href="#cb11-10"></a>    <span class="va">m_val</span> <span class="op">=</span> <span class="kw">new</span> T<span class="op">[</span><span class="va">m_nnz</span><span class="op">];</span></span>
<span id="cb11-11"><a href="#cb11-11"></a></span>
<span id="cb11-12"><a href="#cb11-12"></a>    T<span class="op">*</span> valptr <span class="op">=</span> <span class="va">m_val</span><span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="va">m_cols</span><span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">typename</span> SpMat<span class="op">::</span>InnerIterator pattern_col<span class="op">(</span>pattern<span class="op">,</span> j<span class="op">);</span></span>
<span id="cb11-15"><a href="#cb11-15"></a>            pattern_col<span class="op">;</span> <span class="op">++</span>pattern_col<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>                valptr<span class="op">++</span> <span class="op">=</span> b<span class="op">.</span>coeff<span class="op">(</span>pattern_col<span class="op">.</span>row<span class="op">())</span> <span class="op">*</span> c<span class="op">.</span>coeff<span class="op">(</span>j<span class="op">);</span></span>
<span id="cb11-17"><a href="#cb11-17"></a>            <span class="op">}</span></span>
<span id="cb11-18"><a href="#cb11-18"></a>    <span class="op">}</span></span>
<span id="cb11-19"><a href="#cb11-19"></a>    </span>
<span id="cb11-20"><a href="#cb11-20"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>There’s a little bit of code repeated here, which probably suggests that there is a way to refactor this a little more cleanly, but I really can’t be bothered.</p>
</section>
<section id="adding-the-log-density-to-stan" class="level2">
<h2 class="anchored" data-anchor-id="adding-the-log-density-to-stan">Adding the log-density to Stan</h2>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>and unnecessary gay shit.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Gaussian Multilevel Models.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Actually I got a discounted “youth ticket” the other night because I’m not yet 40. So maybe I’m not ready to star in the remake of one foot in the grave.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>vs the reward<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>vs the weekend<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>In keeping the code stateless we remove the possiblity for a pile of annoying and subtle bugs. So this is a good thing, even when it is inconvenient!<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p>Note that <span class="math inline">\(\sigma\)</span> is a constant, which is different to the usual Stan specification.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>For Markovian models, this is sparse, which allows for fast linear algbra.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>If you’re a crypto-frequentist who needs to compute a Bayes factor, do it on your own time.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>Didn’t work. XLA isn’t optimized for these sorts of methods.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11"><p>The ordering is important her–<a href="https://dansblog.netlify.app/posts/2022-03-23-getting-jax-to-love-sparse-matrices/getting-jax-to-love-sparse-matrices">in a previous post</a> I talked about how important it is to put the dense rows at the back!<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12"><p>This is how eg the horseshoe prior is always implemented<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>Unlike in non-Bayesian mixed effects modelling, where the order of marginalization, profiling, and maximization matter <em>a lot</em>, Bayesian coherence means that it’s all describling joint distribution.<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14"><p>If you pretend I didn’t shit-can the intercept.<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15"><p>Or row if it’s row major<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16"><p>Let’s anthopomorphise. I don’t want to write a blog about caches.<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>Drag name: Cache Mx<a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18"><p>Until you’re rooting around a seventy page compiler error that really just means you forgot a typename on the final <code>return</code>.<a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19"><p>One reason would be to use gradient descent on the score function for a Gaussian MLE. Another is that this might be useful inside the <code>generated quantities</code> block to compute things like the marginal variances of the model, but, as the great lady said, not today Satan.<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20"><p>If you don’t believe me, differentiate both sides of <span class="math inline">\(AC = I\)</span>.<a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents" id="quarto-reuse"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a></div></div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{simpson2024,
  author = {Simpson, Dan},
  title = {Getting Fast Linear Mixed Models into {Stan;} or {I’m} Ok
    with {C++} but {C++} Isn’t Ok with Me.},
  date = {2024-06-05},
  url = {https://dansblog.netlify.app/posts/2024-05-08-laplace/laplace.html},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-simpson2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Simpson, Dan. 2024. <span>“Getting Fast Linear Mixed Models into Stan;
or I’m Ok with C++ but C++ Isn’t Ok with Me.”</span> June 5, 2024. <a href="https://dansblog.netlify.app/posts/2024-05-08-laplace/laplace.html">https://dansblog.netlify.app/posts/2024-05-08-laplace/laplace.html</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/dansblog\.netlify\.app");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>